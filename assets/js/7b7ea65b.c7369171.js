"use strict";(self.webpackChunkpub=self.webpackChunkpub||[]).push([[800],{1988:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"makefile","title":"Makefile","description":"Makefile","source":"@site/docs/makefile.md","sourceDirName":".","slug":"/makefile","permalink":"/docs/makefile","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Makefile","updated":"2021-01-11T10:30:49.000Z","created":"2021-01-19T01:48:48.000Z"},"sidebar":"refSidebar","previous":{"title":"macOS","permalink":"/docs/macOS"},"next":{"title":"MongoDB","permalink":"/docs/mongo"}}');var o=a(4848),r=a(8453);const l={title:"Makefile",updated:new Date("2021-01-11T10:30:49.000Z"),created:new Date("2021-01-19T01:48:48.000Z")},i="Makefile",s={},c=[];function f(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Makefile"}),"\n",(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"makefile",children:"Makefile"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-Makefile",children:"# Set the default goal\n.DEFAULT_GOAL=all\n\n# A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance.\n.PHONY: all clean mostlyclean distclean realclean clobber install print tar shar dist TAGS check test\n\n# Make all the top-level targets the makefile knows about.\nall:\n\n# Delete all files that are normally created by running make.\nclean:\n\n# Like \u2018clean\u2019, but may refrain from deleting a few files that people normally don\u2019t want to recompile. For example, the \u2018mostlyclean\u2019 target for GCC does not delete libgcc.a, because recompiling it is rarely necessary and takes a lot of time.\nmostlyclean:\n\n# Any of these targets might be defined to delete more files than \u2018clean\u2019 does. For example, this would delete configuration files or links that you would normally create as preparation for compilation, even if the makefile itself cannot create these files.\ndistclean:\nrealclean:\nclobber:\n\n# Copy the executable file into a directory that users typically search for commands; copy any auxiliary files that the executable uses into the directories where it will look for them.\ninstall:\n\n# Print listings of the source files that have changed.\nprint:\n\n# Create a tar file of the source files.\ntar:\n\n# Create a shell archive (shar file) of the source files.\nshar:\n\n# Create a distribution file of the source files. This might be a tar file, or a shar file, or a compressed version of one of the above, or even more than one of the above.\ndist:\n\n# Update a tags table for this program.\nTAGS:\n\n# Perform self tests on the program this makefile builds.\ncheck:\ntest:\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(f,{...e})}):f(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>l,x:()=>i});var n=a(6540);const o={},r=n.createContext(o);function l(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);