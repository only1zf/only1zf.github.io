<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-linux-perf-examples" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.1">
<title data-rh="true">linux-perf-examples | Fan&#x27;s life</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://only1zf.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://only1zf.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://only1zf.com/docs/linux-perf-examples"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="linux-perf-examples | Fan&#x27;s life"><meta data-rh="true" name="description" content="Linux perf Examples"><meta data-rh="true" property="og:description" content="Linux perf Examples"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://only1zf.com/docs/linux-perf-examples"><link data-rh="true" rel="alternate" href="https://only1zf.com/docs/linux-perf-examples" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://only1zf.com/docs/linux-perf-examples" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5bb4ad6d.css">
<script src="/assets/js/runtime~main.eacc00ae.js" defer="defer"></script>
<script src="/assets/js/main.e354d407.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Fan&#x27;s life</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/randt">读考</a><a class="navbar__item navbar__link" href="/docs/prompts/dict">Prompts</a><a class="navbar__item navbar__link" href="/docs/refs/a-successful-git-branching-model">References</a><a class="navbar__item navbar__link" href="/docs/excerpts/a-common-translation-prompt-for-different-languages">Excerpts</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><main class="docMainContainer_TBSr docMainContainerEnhanced_lQrH"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>linux-perf-examples</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="linux-perf-examples">Linux perf Examples<a href="#linux-perf-examples" class="hash-link" aria-label="Linux perf Examples的直接链接" title="Linux perf Examples的直接链接" translate="no">​</a></h2>
<p>These are some examples of using the <a href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="noopener noreferrer">perf</a> Linux profiler, which has also been called Performance Counters for Linux (PCL), Linux perf events (LPE), or perf_events. Like <a href="http://web.eece.maine.edu/~vweaver/projects/perf_events/" target="_blank" rel="noopener noreferrer">Vince Weaver</a>, I&#x27;ll call it perf_events so that you can search on that term later. Searching for just &quot;perf&quot; finds sites on the police, petroleum, weed control, and a <a href="https://www.brendangregg.com/perf_events/omg-so-perf.jpg" target="_blank" rel="noopener noreferrer">T-shirt</a>. This is not an official perf page, for either perf_events or the T-shirt.</p>
<p>perf_events is an event-oriented observability tool, which can help you solve advanced performance and troubleshooting functions. Questions that can be answered include:</p>
<ul>
<li>Why is the kernel on-CPU so much? What code-paths?</li>
<li>Which code-paths are causing CPU level 2 cache misses?</li>
<li>Are the CPUs stalled on memory I/O?</li>
<li>Which code-paths are allocating memory, and how much?</li>
<li>What is triggering TCP retransmits?</li>
<li>Is a certain kernel function being called, and how often?</li>
<li>What reasons are threads leaving the CPU?</li>
</ul>
<p>perf_events is part of the Linux kernel, under tools/perf. While it uses many Linux tracing features, some are not yet exposed via the perf command, and need to be used via the ftrace interface instead. My <a href="https://github.com/brendangregg/perf-tools" target="_blank" rel="noopener noreferrer">perf-tools</a> collection (github) uses both perf_events and ftrace as needed.</p>
<p>This page includes my examples of perf_events. A table of contents:</p>
<table><thead><tr><th><a href="https://www.brendangregg.com/#Screenshot" target="_blank" rel="noopener noreferrer">1. Screenshot</a>   <a href="https://www.brendangregg.com/#OneLiners" target="_blank" rel="noopener noreferrer">2. One-Liners</a>   <a href="https://www.brendangregg.com/#Presentations" target="_blank" rel="noopener noreferrer">3. Presentations</a>   <a href="https://www.brendangregg.com/#Background" target="_blank" rel="noopener noreferrer">4. Background</a>   <a href="https://www.brendangregg.com/#Prerequisites" target="_blank" rel="noopener noreferrer">4.1. Prerequisites</a>   <a href="https://www.brendangregg.com/#Symbols" target="_blank" rel="noopener noreferrer">4.2. Symbols</a>   <a href="https://www.brendangregg.com/#JIT_Symbols" target="_blank" rel="noopener noreferrer">4.3. JIT Symbols (Java, Node.js)</a>   <a href="https://www.brendangregg.com/#StackTraces" target="_blank" rel="noopener noreferrer">4.4. Stack Traces</a>   <a href="https://www.brendangregg.com/#Audience" target="_blank" rel="noopener noreferrer">4.5. Audience</a>   <a href="https://www.brendangregg.com/#Usage" target="_blank" rel="noopener noreferrer">4.6. Usage</a>   <a href="https://www.brendangregg.com/#UsageExamples" target="_blank" rel="noopener noreferrer">4.7. Usage Examples</a>   <a href="https://www.brendangregg.com/#SpecialUsage" target="_blank" rel="noopener noreferrer">4.8. Special Usage</a></th><th><a href="https://www.brendangregg.com/#Events" target="_blank" rel="noopener noreferrer">5. Events</a>   <a href="https://www.brendangregg.com/#SoftwareEvents" target="_blank" rel="noopener noreferrer">5.1. Software Events</a>   <a href="https://www.brendangregg.com/#HardwareEvents" target="_blank" rel="noopener noreferrer">5.2. Hardware Events (PMCs)</a>   <a href="https://www.brendangregg.com/#Tracepoints" target="_blank" rel="noopener noreferrer">5.3. Kernel Tracepoints</a>   <a href="https://www.brendangregg.com/#USDT" target="_blank" rel="noopener noreferrer">5.4. USDT</a>   <a href="https://www.brendangregg.com/#DynamicTracing" target="_blank" rel="noopener noreferrer">5.5. Dynamic Tracing</a>   <a href="https://www.brendangregg.com/#Examples" target="_blank" rel="noopener noreferrer">6. Examples</a>   <a href="https://www.brendangregg.com/#CPUstatistics" target="_blank" rel="noopener noreferrer">6.1. CPU Statistics</a>   <a href="https://www.brendangregg.com/#TimedProfiling" target="_blank" rel="noopener noreferrer">6.2. Timed Profiling</a>   <a href="https://www.brendangregg.com/#EventProfiling" target="_blank" rel="noopener noreferrer">6.3. Event Profiling</a>   <a href="https://www.brendangregg.com/#StaticKernelTracing" target="_blank" rel="noopener noreferrer">6.4. Static Kernel Tracing</a>   <a href="https://www.brendangregg.com/#StaticUserTracing" target="_blank" rel="noopener noreferrer">6.5. Static User Tracing</a></th><th><a href="https://www.brendangregg.com/#DynamicTracingEg" target="_blank" rel="noopener noreferrer">6.6. Dynamic Tracing</a>   <a href="https://www.brendangregg.com/#SchedulerAnalysis" target="_blank" rel="noopener noreferrer">6.7. Scheduler Analysis</a>   <a href="https://www.brendangregg.com/#eBPF" target="_blank" rel="noopener noreferrer">6.8. eBPF</a>   <a href="https://www.brendangregg.com/#Visualizations" target="_blank" rel="noopener noreferrer">7. Visualizations</a>   <a href="https://www.brendangregg.com/#FlameGraphs" target="_blank" rel="noopener noreferrer">7.1. Flame Graphs</a>   <a href="https://www.brendangregg.com/#HeatMaps" target="_blank" rel="noopener noreferrer">7.2. Heat Maps</a>   <a href="https://www.brendangregg.com/#Targets" target="_blank" rel="noopener noreferrer">8. Targets</a>   <a href="https://www.brendangregg.com/#More" target="_blank" rel="noopener noreferrer">9. More</a>   <a href="https://www.brendangregg.com/#Building" target="_blank" rel="noopener noreferrer">10. Building</a>   <a href="https://www.brendangregg.com/#Troubleshooting" target="_blank" rel="noopener noreferrer">11. Troubleshooting</a>   <a href="https://www.brendangregg.com/#OtherTools" target="_blank" rel="noopener noreferrer">12. Other Tools</a>   <a href="https://www.brendangregg.com/#Resources" target="_blank" rel="noopener noreferrer">13. Resources</a></th></tr></thead></table>
<p>Key sections to start with are: <a href="https://www.brendangregg.com/#Events" target="_blank" rel="noopener noreferrer">Events</a>, <a href="https://www.brendangregg.com/#OneLiners" target="_blank" rel="noopener noreferrer">One-Liners</a>, <a href="https://www.brendangregg.com/#Presentations" target="_blank" rel="noopener noreferrer">Presentations</a>, <a href="https://www.brendangregg.com/#Prerequisites" target="_blank" rel="noopener noreferrer">Prerequisites</a>, <a href="https://www.brendangregg.com/#CPUstatistics" target="_blank" rel="noopener noreferrer">CPU statistics</a>, <a href="https://www.brendangregg.com/#TimedProfiling" target="_blank" rel="noopener noreferrer">Timed Profiling</a>, and <a href="https://www.brendangregg.com/#FlameGraphs" target="_blank" rel="noopener noreferrer">Flame Graphs</a>. Also see my <a href="https://www.brendangregg.com/#Posts" target="_blank" rel="noopener noreferrer">Posts</a> about perf_events, and <a href="https://www.brendangregg.com/#Links" target="_blank" rel="noopener noreferrer">Links</a> for the main (official) perf_events page, awesome tutorial, and other links. The next sections introduce perf_events further, starting with a screenshot, one-liners, and then background.</p>
<p>This page is under construction, and there&#x27;s a lot more to perf_events that I&#x27;d like to add. Hopefully this is useful so far.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-screenshot">1. Screenshot<a href="#1-screenshot" class="hash-link" aria-label="1. Screenshot的直接链接" title="1. Screenshot的直接链接" translate="no">​</a></h2>
<p>Starting with a screenshot, here&#x27;s perf version 3.9.3 tracing disk I/O:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e block:block_rq_issue -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ls -l perf.data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw------- 1 root root 3458162 Jan 26 03:03 perf.data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf report</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Samples: 2K of event &#x27;block:block_rq_issue&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Event count (approx.): 2216</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Overhead       Command      Shared Object                Symbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ........  ............  .................  ....................</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    32.13%            dd  [kernel.kallsyms]  [k] blk_peek_request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      --- blk_peek_request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          virtblk_request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          __blk_run_queue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |--98.31%-- queue_unplugged</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          blk_flush_plug_list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |--91.00%-- blk_queue_bio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          generic_make_request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          submit_bio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          ext4_io_submit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |--58.71%-- ext4_bio_write_page</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          mpage_da_submit_io</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          mpage_da_map_and_submit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          write_cache_pages_da</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          ext4_da_writepages</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          do_writepages</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          __filemap_fdatawrite_range</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          filemap_flush</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          ext4_alloc_da_blocks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          ext4_release_file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          __fput</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          ____fput</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          task_work_run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          do_notify_resume</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          int_signal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          close</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          0x0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |           --41.29%-- mpage_da_submit_io</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>A perf record command was used to trace the block<!-- -->:block<!-- -->_rq_issue probe, which fires when a block device I/O request is issued (disk I/O). Options included -a to trace all CPUs, and -g to capture call graphs (stack traces). Trace data is written to a perf.data file, and tracing ended when Ctrl-C was hit. A summary of the perf.data file was printed using perf report, which builds a tree from the stack traces, coalescing common paths, and showing percentages for each path.</p>
<p>The perf report output shows that 2,216 events were traced (disk I/O), 32% of which from a dd command. These were issued by the kernel function blk_peek_request(), and walking down the stacks, about half of these 32% were from the close() system call.</p>
<p>Note that I use the &quot;#&quot; prompt to signify that these commands were run as root, and I&#x27;ll use &quot;$&quot; for user commands. Use sudo as needed.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-one-liners">2. One-Liners<a href="#2-one-liners" class="hash-link" aria-label="2. One-Liners的直接链接" title="2. One-Liners的直接链接" translate="no">​</a></h2>
<p>Some useful one-liners I&#x27;ve gathered or written. Terminology I&#x27;m using, from lowest to highest overhead:</p>
<ul>
<li><strong>statistics</strong> / <strong>count</strong>: increment an integer counter on events</li>
<li><strong>sample</strong>: collect details (eg, instruction pointer or stack) from a subset of events (once every...)</li>
<li><strong>trace</strong>: collect details from every event</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="listing-events">Listing Events<a href="#listing-events" class="hash-link" aria-label="Listing Events的直接链接" title="Listing Events的直接链接" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Listing all currently known events:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Listing sched tracepoints:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf list &#x27;sched:*&#x27;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="counting-events">Counting Events<a href="#counting-events" class="hash-link" aria-label="Counting Events的直接链接" title="Counting Events的直接链接" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># CPU counter statistics for the specified command:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Detailed CPU counter statistics (includes extras) for the specified command:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -d command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># CPU counter statistics for the specified PID, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -p PID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># CPU counter statistics for the entire system, for 5 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -a sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Various basic CPU statistics, system wide, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e cycles,instructions,cache-references,cache-misses,bus-cycles -a sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Various CPU level 1 data cache statistics for the specified command:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Various CPU data TLB statistics for the specified command:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e dTLB-loads,dTLB-load-misses,dTLB-prefetch-misses command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Various CPU last level cache statistics for the specified command:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e LLC-loads,LLC-load-misses,LLC-stores,LLC-prefetches command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Using raw PMC counters, eg, counting unhalted core cycles:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e r003c -a sleep 5 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># PMCs: counting cycles and frontend stalls via raw specification:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e cycles -e cpu/event=0x0e,umask=0x01,inv,cmask=0x01/ -a sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Count syscalls per-second system-wide:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e raw_syscalls:sys_enter -I 1000 -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Count system calls by type for the specified PID, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e &#x27;syscalls:sys_enter_*&#x27; -p PID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Count system calls by type for the entire system, for 5 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e &#x27;syscalls:sys_enter_*&#x27; -a sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Count scheduler events for the specified PID, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e &#x27;sched:*&#x27; -p PID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Count scheduler events for the specified PID, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e &#x27;sched:*&#x27; -p PID sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Count ext4 events for the entire system, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e &#x27;ext4:*&#x27; -a sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Count block device I/O events for the entire system, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e &#x27;block:*&#x27; -a sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Count all vmscan events, printing a report every second:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf stat -e &#x27;vmscan:*&#x27; -a -I 1000</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="profiling">Profiling<a href="#profiling" class="hash-link" aria-label="Profiling的直接链接" title="Profiling的直接链接" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Sample on-CPU functions for the specified command, at 99 Hertz:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample on-CPU functions for the specified PID, at 99 Hertz, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -p PID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample on-CPU functions for the specified PID, at 99 Hertz, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -p PID sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces (via frame pointers) for the specified PID, at 99 Hertz, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -p PID -g -- sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces for the PID, using dwarf (dbg info) to unwind stacks, at 99 Hertz, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -p PID --call-graph dwarf sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (&lt; Linux 4.11):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -ag -- sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (&gt;= Linux 4.11):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -g -- sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># If the previous command didn&#x27;t work, try forcing perf to use the cpu-clock event:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -e cpu-clock -ag -- sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces for a container identified by its /sys/fs/cgroup/perf_event cgroup:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -e cpu-clock --cgroup=docker/1d567f4393190204...etc... -a -- sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces for the entire system, with dwarf stacks, at 99 Hertz, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -a --call-graph dwarf sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces for the entire system, using last branch record for stacks, ... (&gt;= Linux 4.?):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 99 -a --call-graph lbr sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces, once every 10,000 Level 1 data cache misses, for 5 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e L1-dcache-load-misses -c 10000 -ag -- sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU stack traces, once every 100 last level cache misses, for 5 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e LLC-load-misses -c 100 -ag -- sleep 5 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample on-CPU kernel instructions, for 5 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e cycles:k -a -- sleep 5 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample on-CPU user instructions, for 5 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e cycles:u -a -- sleep 5 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample on-CPU user instructions precisely (using PEBS), for 5 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e cycles:up -a -- sleep 5 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Perform branch tracing (needs HW support), for 1 second:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -b -a sleep 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPUs at 49 Hertz, and show top addresses and symbols, live (no perf.data file):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf top -F 49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPUs at 49 Hertz, and show top process names and segments, live:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf top -F 49 -ns comm,dso</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="static-tracing">Static Tracing<a href="#static-tracing" class="hash-link" aria-label="Static Tracing的直接链接" title="Static Tracing的直接链接" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Trace new processes, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e sched:sched_process_exec -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample (take a subset of) context-switches, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e context-switches -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all context-switches, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e context-switches -c 1 -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Include raw settings used (see: man perf_event_open):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -vv -e context-switches -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all context-switches via sched tracepoint, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e sched:sched_switch -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample context-switches with stack traces, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e context-switches -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample context-switches with stack traces, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e context-switches -ag -- sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CS, stack traces, and with timestamps (&lt; Linux 3.17, -T now default):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e context-switches -ag -T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample CPU migrations, for 10 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e migrations -a -- sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all connect()s with stack traces (outbound connections), until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e syscalls:sys_enter_connect -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all accepts()s with stack traces (inbound connections), until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e syscalls:sys_enter_accept* -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all block device (disk I/O) requests with stack traces, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e block:block_rq_insert -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample at most 100 block device requests per second, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F 100 -e block:block_rq_insert -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all block device issues and completions (has timestamps), until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e block:block_rq_issue -e block:block_rq_complete -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all block completions, of size at least 100 Kbytes, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e block:block_rq_complete --filter &#x27;nr_sector &gt; 200&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all block completions, synchronous writes only, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e block:block_rq_complete --filter &#x27;rwbs == &quot;WS&quot;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all block completions, all types of writes, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e block:block_rq_complete --filter &#x27;rwbs ~ &quot;*W*&quot;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample minor faults (RSS growth) with stack traces, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e minor-faults -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all minor faults with stack traces, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e minor-faults -c 1 -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample page faults with stack traces, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e page-faults -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace all ext4 calls, and write to a non-ext4 location, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e &#x27;ext4:*&#x27; -o /tmp/perf.data -a </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace kswapd wakeup events, until Ctrl-C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e vmscan:mm_vmscan_wakeup_kswapd -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add Node.js USDT probes (Linux 4.10+):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf buildid-cache --add \`which node\`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace the node http__server__request USDT event (Linux 4.10+):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e sdt_node:http__server__request -a</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-tracing">Dynamic Tracing<a href="#dynamic-tracing" class="hash-link" aria-label="Dynamic Tracing的直接链接" title="Dynamic Tracing的直接链接" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for the kernel tcp_sendmsg() function entry (&quot;--add&quot; is optional):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe --add tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Remove the tcp_sendmsg() tracepoint (or use &quot;--del&quot;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -d tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for the kernel tcp_sendmsg() function return:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;tcp_sendmsg%return&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Show available variables for the kernel tcp_sendmsg() function (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -V tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Show available variables for the kernel tcp_sendmsg() function, plus external vars (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -V tcp_sendmsg --externs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Show available line probes for tcp_sendmsg() (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -L tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Show available variables for tcp_sendmsg() at line number 81 (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -V tcp_sendmsg:81</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for tcp_sendmsg(), with three entry argument registers (platform specific):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;tcp_sendmsg %ax %dx %cx&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for tcp_sendmsg(), with an alias (&quot;bytes&quot;) for the %cx register (platform specific):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;tcp_sendmsg bytes=%cx&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace previously created probe when the bytes (alias) variable is greater than 100:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e probe:tcp_sendmsg --filter &#x27;bytes &gt; 100&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for tcp_sendmsg() return, and capture the return value:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;tcp_sendmsg%return $retval&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for tcp_sendmsg(), and &quot;size&quot; entry argument (reliable, but needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;tcp_sendmsg size&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for tcp_sendmsg(), with size and socket state (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;tcp_sendmsg size sk-&gt;__sk_common.skc_state&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Tell me how on Earth you would do this, but don&#x27;t actually do it (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -nv &#x27;tcp_sendmsg size sk-&gt;__sk_common.skc_state&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace previous probe when size is non-zero, and state is not TCP_ESTABLISHED(1) (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e probe:tcp_sendmsg --filter &#x27;size &gt; 0 &amp;&amp; skc_state != 1&#x27; -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for tcp_sendmsg() line 81 with local variable seglen (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;tcp_sendmsg:81 seglen&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for do_sys_open() with the filename as a string (needs debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;do_sys_open filename:string&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for myfunc() return, and include the retval as a string:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe &#x27;myfunc%return +0($retval):string&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for the user-level malloc() function from libc:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -x /lib64/libc.so.6 malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Add a tracepoint for this user-level static probe (USDT, aka SDT event):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -x /usr/lib64/libpthread-2.24.so %sdt_libpthread:mutex_entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># List currently available dynamic probes:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf probe -l</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mixed">Mixed<a href="#mixed" class="hash-link" aria-label="Mixed的直接链接" title="Mixed的直接链接" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Trace system calls by process, showing a summary refreshing every 2 seconds:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf top -e raw_syscalls:sys_enter -ns comm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Trace sent network packets by on-CPU process, rolling output (no clear):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stdbuf -oL perf top -e net:net_dev_xmit -ns comm | strings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample stacks at 99 Hertz, and, context switches:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F99 -e cpu-clock -e cs -a -g </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Sample stacks to 2 levels deep, and, context switch stacks to 5 levels (needs 4.8):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf record -F99 -e cpu-clock/max-stack=2/ -e cs/max-stack=5/ -a -g</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="special">Special<a href="#special" class="hash-link" aria-label="Special的直接链接" title="Special的直接链接" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Record cacheline events (Linux 4.10+):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf c2c record -a -- sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Report cacheline events from previous recording (Linux 4.10+):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf c2c report</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reporting">Reporting<a href="#reporting" class="hash-link" aria-label="Reporting的直接链接" title="Reporting的直接链接" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Show perf.data in an ncurses browser (TUI) if possible:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf report</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Show perf.data with a column for sample count:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf report -n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Show perf.data as a text report, with data coalesced and percentages:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf report --stdio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Report, with stacks in folded format: one line per stack (needs 4.4):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf report --stdio -n -g folded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># List all events from perf.data:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># List all perf.data events, with data header (newer kernels; was previously default):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf script --header</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># List all perf.data events, with customized fields (&lt; Linux 4.1):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf script -f time,event,trace</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># List all perf.data events, with customized fields (&gt;= Linux 4.1):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf script -F time,event,trace</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># List all perf.data events, with my recommended fields (needs record -a; newer kernels):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf script --header -F comm,pid,tid,cpu,time,event,ip,sym,dso </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># List all perf.data events, with my recommended fields (needs record -a; older kernels):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf script -f comm,pid,tid,cpu,time,event,ip,sym,dso</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Dump raw contents from perf.data as hex (for debugging):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf script -D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Disassemble and annotate instructions with percentages (needs some debuginfo):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf annotate --stdio</span><br></span></code></pre></div></div>
<p>These one-liners serve to illustrate the capabilities of perf_events, and can also be used a bite-sized tutorial: learn perf_events one line at a time. You can also print these out as a perf_events cheatsheet.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-presentations">3. Presentations<a href="#3-presentations" class="hash-link" aria-label="3. Presentations的直接链接" title="3. Presentations的直接链接" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kernel-recipes-2017">Kernel Recipes (2017)<a href="#kernel-recipes-2017" class="hash-link" aria-label="Kernel Recipes (2017)的直接链接" title="Kernel Recipes (2017)的直接链接" translate="no">​</a></h3>
<p>At <a href="https://kernel-recipes.org/en/2017/talks/perf-in-netflix/" target="_blank" rel="noopener noreferrer">Kernel Recipes 2017</a> I gave an updated talk on Linux perf at Netflix, focusing on getting CPU profiling and flame graphs to work. This talk includes a crash course on perf_events, plus gotchas such as fixing stack traces and symbols when profiling Java, Node.js, VMs, and containers.</p>
<p>A video of the talk is on <a href="https://www.youtube.com/watch?v=UVM3WX8Lq2k" target="_blank" rel="noopener noreferrer">youtube</a> and the slides are on <a href="https://www.slideshare.net/brendangregg/kernel-recipes-2017-using-linux-perf-at-netflix" target="_blank" rel="noopener noreferrer">slideshare</a>:</p>
<p><a href="https://www.youtube.com/watch?v=UVM3WX8Lq2k" target="_blank" rel="noopener noreferrer"><img decoding="async" loading="lazy" src="/assets/images/93a7e3d6d017d7c7878ebf8b723be3f0_MD5-0f9aaec5326479a0076ec8cb71a8efae.png" width="520" height="291" class="img_ev3q"></a></p>
<p>There&#x27;s also an older version of this talk from 2015, which I&#x27;ve <a href="https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html" target="_blank" rel="noopener noreferrer">posted</a> about.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-background">4. Background<a href="#4-background" class="hash-link" aria-label="4. Background的直接链接" title="4. Background的直接链接" translate="no">​</a></h2>
<p>The following sections provide some background for understanding perf_events and how to use it. I&#x27;ll describe the prerequisites, audience, usage, events, and tracepoints.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="41-prerequisites">4.1. Prerequisites<a href="#41-prerequisites" class="hash-link" aria-label="4.1. Prerequisites的直接链接" title="4.1. Prerequisites的直接链接" translate="no">​</a></h2>
<p>The perf tool is in the <strong>linux-tools-common</strong> package. Start by adding that, then running &quot; perf &quot; to see if you get the USAGE message. It may tell you to install another related package (linux-tools- <em>kernelversion</em>).</p>
<p>You can also build and add perf from the Linux kernel source. See the <a href="https://www.brendangregg.com/#Building" target="_blank" rel="noopener noreferrer">Building</a> section.</p>
<p>To get the most out perf, you&#x27;ll want symbols and stack traces. These may work by default in your Linux distribution, or they may require the addition of packages, or recompilation of the kernel with additional config options.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="42-symbols">4.2. Symbols<a href="#42-symbols" class="hash-link" aria-label="4.2. Symbols的直接链接" title="4.2. Symbols的直接链接" translate="no">​</a></h2>
<p>perf_events, like other debug tools, needs symbol information (symbols). These are used to translate memory addresses into function and variable names, so that they can be read by us humans. Without symbols, you&#x27;ll see hexadecimal numbers representing the memory addresses profiled.</p>
<p>The following perf report output shows stack traces, however, only hexadecimal numbers can be seen:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">57.14%     sshd  libc-2.15.so        [.] connect           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- connect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--25.00%-- 0x7ff3c1cddf29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--25.00%-- 0x7ff3bfe82761</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          0x7ff3bfe82b7c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--25.00%-- 0x7ff3bfe82dfc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   --25.00%-- [...]</span><br></span></code></pre></div></div>
<p>If the software was added by packages, you may find debug packages (often &quot;-dbgsym&quot;) which provide the symbols. Sometimes perf report will tell you to install these, eg: &quot;no symbols found in /bin/dd, maybe install a debug package?&quot;.</p>
<p>Here&#x27;s the same perf report output seen earlier, after adding openssh-server-dbgsym and libc6-dbgsym (this is on ubuntu 12.04):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">57.14%     sshd  libc-2.15.so        [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--25.00%-- add_one_listen_addr.isra.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--25.00%-- __nscd_get_mapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          __nscd_get_map_ref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--25.00%-- __nscd_open_socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   --25.00%-- [...]</span><br></span></code></pre></div></div>
<p>I find it useful to add both libc6-dbgsym and coreutils-dbgsym, to provide some symbol coverage of user-level OS codepaths.</p>
<p>Another way to get symbols is to compile the software yourself. For example, I just compiled node (Node.js):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># file node-v0.10.28/out/Release/node </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node-v0.10.28/out/Release/node: ELF 64-bit LSB executable, ... not stripped</span><br></span></code></pre></div></div>
<p>This has not been stripped, so I can profile node and see more than just hex. If the result is stripped, configure your build system not to run strip(1) on the output binaries.</p>
<p>Kernel-level symbols are in the kernel debuginfo package, or when the kernel is compiled with CONFIG_KALLSYMS.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="43-jit-symbols-java-nodejs">4.3. JIT Symbols (Java, Node.js)<a href="#43-jit-symbols-java-nodejs" class="hash-link" aria-label="4.3. JIT Symbols (Java, Node.js)的直接链接" title="4.3. JIT Symbols (Java, Node.js)的直接链接" translate="no">​</a></h2>
<p>Programs that have virtual machines (VMs), like Java&#x27;s JVM and node&#x27;s v8, execute their own virtual processor, which has its own way of executing functions and managing stacks. If you profile these using perf_events, you&#x27;ll see symbols for the VM engine, which have some use (eg, to identify if time is spent in GC), but you won&#x27;t see the language-level context you might be expecting. Eg, you won&#x27;t see Java classes and methods.</p>
<p>perf_events has JIT support to solve this, which requires the VM to maintain a /tmp/perf-PID.map file for symbol translation. Java can do this with <a href="https://github.com/jvm-profiling-tools/perf-map-agent" target="_blank" rel="noopener noreferrer">perf-map-agent</a>, and Node.js 0.11.13+ with --perf_basic_prof. See my blog post <a href="http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html" target="_blank" rel="noopener noreferrer">Node.js flame graphs on Linux</a> for the steps.</p>
<p>Note that Java may not show full stacks to begin with, due to hotspot on x86 omitting the frame pointer (just like gcc). On newer versions (JDK 8u60+), you can use the -XX:+PreserveFramePointer option to fix this behavior, and profile fully using perf. See my Netflix Tech Blog post, <a href="http://techblog.netflix.com/2015/07/java-in-flames.html" target="_blank" rel="noopener noreferrer">Java in Flames</a>, for a full writeup, and my <a href="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#Java" target="_blank" rel="noopener noreferrer">Java flame graphs</a> section, which links to an older patch and includes an example resulting flame graph. I also summarized the latest in my JavaOne 2016 talk <a href="http://www.slideshare.net/brendangregg/java-performance-analysis-on-linux-with-flame-graphs" target="_blank" rel="noopener noreferrer">Java Performance Analysis on Linux with Flame Graphs</a>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="44-stack-traces">4.4 Stack Traces<a href="#44-stack-traces" class="hash-link" aria-label="4.4 Stack Traces的直接链接" title="4.4 Stack Traces的直接链接" translate="no">​</a></h2>
<p>Always compile with frame pointers. Omitting frame pointers is an evil compiler optimization that breaks debuggers, and sadly, is often the default. Without them, you may see incomplete stacks from perf_events, like seen in the earlier sshd symbols example. There are three ways to fix this: either using dwarf data to unwind the stack, using last branch record (LBR) if available (a processor feature), or returning the frame pointers.</p>
<p>There are other stack walking techniques, like BTS (Branch Trace Store), and the new ORC unwinder. I&#x27;ll add docs for them at some point (and as perf support arrives).</p>
<p><strong>Frame Pointers</strong></p>
<p>The earlier sshd example was a default build of OpenSSH, which uses compiler optimizations (-O2), which in this case has omitted the frame pointer. Here&#x27;s how it looks after recompiling OpenSSH with <strong>-fno-omit-frame-pointer</strong>:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">100.00%     sshd  libc-2.15.so   [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--30.00%-- add_one_listen_addr.isra.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          add_listen_addr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          fill_default_server_options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          __libc_start_main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--20.00%-- __nscd_get_mapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          __nscd_get_map_ref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--20.00%-- __nscd_open_socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   --30.00%-- [...]</span><br></span></code></pre></div></div>
<p>Now the ancestry from add_one_listen_addr() can be seen, down to main() and __libc_start_main().</p>
<p>The kernel can suffer the same problem. Here&#x27;s an example CPU profile collected on an idle server, with stack traces (-g):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">99.97%  swapper  [kernel.kallsyms]  [k] default_idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            --- default_idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.03%     sshd  [kernel.kallsyms]  [k] iowrite16   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- iowrite16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   __write_nocancel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   (nil)</span><br></span></code></pre></div></div>
<p>The kernel stack traces are incomplete. Now a similar profile with <strong>CONFIG_FRAME_POINTER=y</strong>:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">99.97%  swapper  [kernel.kallsyms]  [k] default_idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            --- default_idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cpu_idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |--87.50%-- start_secondary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                --12.50%-- rest_init</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          start_kernel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          x86_64_start_reservations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          x86_64_start_kernel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.03%     sshd  [kernel.kallsyms]  [k] iowrite16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- iowrite16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   vp_notify</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   virtqueue_kick</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   start_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   dev_hard_start_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   sch_direct_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   dev_queue_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ip_finish_output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ip_output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ip_local_out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ip_queue_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   tcp_transmit_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   tcp_write_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   __tcp_push_pending_frames</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   inet_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   sock_aio_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   do_sync_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   vfs_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   sys_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   system_call_fastpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   __write_nocancel</span><br></span></code></pre></div></div>
<p>Much better -- the entire path from the write() syscall (__write_nocancel) to iowrite16() can be seen.</p>
<p><strong>Dwarf</strong></p>
<p>Since about the 3.9 kernel, perf_events has supported a workaround for missing frame pointers in user-level stacks: libunwind, which uses dwarf. This can be enabled using &quot;--call-graph dwarf&quot; (or &quot;-g dwarf&quot;).</p>
<p>Also see the <a href="https://www.brendangregg.com/#Building" target="_blank" rel="noopener noreferrer">Building</a> section for other notes about building perf_events, as without the right library, it may build itself without dwarf support.</p>
<p><strong>LBR</strong></p>
<p>You must have Last Branch Record access to be able to use this. It is disabled in most cloud environments, where you&#x27;ll get this error:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -F 99 -a --call-graph lbr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Error:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PMU Hardware doesn&#x27;t support sampling/overflow-interrupts.</span><br></span></code></pre></div></div>
<p>Here&#x27;s an example of it working:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -F 99 -a --call-graph lbr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.903 MB perf.data (163 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stackcollapse-p 23867 [007] 4762187.971824:   29003297 cycles:ppp:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  1430c0 Perl_re_intuit_start (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  144118 Perl_regexec_flags (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   cfcc9 Perl_pp_match (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   cbee3 Perl_runops_standard (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   51fb3 perl_run (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   2b168 main (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stackcollapse-p 23867 [007] 4762187.980184:   31532281 cycles:ppp:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   e3660 Perl_sv_force_normal_flags (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  109b86 Perl_leave_scope (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  1139db Perl_pp_leave (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   cbee3 Perl_runops_standard (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   51fb3 perl_run (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   2b168 main (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stackcollapse-p 23867 [007] 4762187.989283:   32341031 cycles:ppp:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   cfae0 Perl_pp_match (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   cbee3 Perl_runops_standard (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   51fb3 perl_run (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   2b168 main (/usr/bin/perl)</span><br></span></code></pre></div></div>
<p>Nice! Note that LBR is usually limited in stack depth (either 8, 16, or 32 frames), so it may not be suitable for deep stacks or flame graph generation, as flame graphs need to walk to the common root for merging.</p>
<p>Here&#x27;s that same program sampled using the by-default frame pointer walk:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -F 99 -a -g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.882 MB perf.data (81 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stackcollapse-p 23883 [005] 4762405.747834:   35044916 cycles:ppp:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  135b83 [unknown] (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stackcollapse-p 23883 [005] 4762405.757935:   35036297 cycles:ppp:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ee67d Perl_sv_gets (/usr/bin/perl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stackcollapse-p 23883 [005] 4762405.768038:   35045174 cycles:ppp:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  137334 [unknown] (/usr/bin/perl)</span><br></span></code></pre></div></div>
<p>You can recompile Perl with frame pointer support (in its./Configure, it asks what compiler options: add -fno-omit-frame-pointer). Or you can use LBR if it&#x27;s available, and you don&#x27;t need very long stacks.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="45-audience">4.5. Audience<a href="#45-audience" class="hash-link" aria-label="4.5. Audience的直接链接" title="4.5. Audience的直接链接" translate="no">​</a></h2>
<p>To use perf_events, you&#x27;ll either:</p>
<ul>
<li>Develop your own commands</li>
<li>Run example commands</li>
</ul>
<p>Developing new invocations of perf_events requires the study of kernel and application code, which isn&#x27;t for everyone. Many more people will use perf_events by running commands developed by other people, like the examples on this page. This can work out fine: your organization may only need one or two people who can develop perf_events commands or source them, and then share them for use by the entire operation and support groups.</p>
<p>Either way, you need to know the capabilities of perf_events so you know when to reach for it, whether that means searching for an example command or writing your own. One goal of the examples that follow is just to show you what can be done, to help you learn these capabilities. You should also browse examples on other sites (<a href="https://www.brendangregg.com/#Links" target="_blank" rel="noopener noreferrer">Links</a>).</p>
<p>If you&#x27;ve never used perf_events before, you may want to test before production use (it has had <a href="http://web.eecs.utk.edu/~vweaver1/projects/perf-events/kernel_panics.html" target="_blank" rel="noopener noreferrer">kernel panic</a> bugs in the past). My experience has been a good one (no panics).</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="46-usage">4.6. Usage<a href="#46-usage" class="hash-link" aria-label="4.6. Usage的直接链接" title="4.6. Usage的直接链接" translate="no">​</a></h2>
<p>perf_events provides a command line tool, perf, and subcommands for various profiling activities. This is a single interface for the different instrumentation frameworks that provide the various events.</p>
<p>The perf command alone will list the subcommands; here is perf version 4.10 (for the Linux 4.10 kernel):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usage: perf [--version] [--help] [OPTIONS] COMMAND [ARGS]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> The most commonly used perf commands are:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   annotate        Read perf.data (created by perf record) and display annotated code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   archive         Create archive with object files with build-ids found in perf.data file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bench           General framework for benchmark suites</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   buildid-cache   Manage build-id cache.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   buildid-list    List the buildids in a perf.data file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   config          Get and set variables in a configuration file.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   data            Data file related processing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   diff            Read perf.data files and display the differential profile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   evlist          List the event names in a perf.data file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   inject          Filter to augment the events stream with additional information</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   kmem            Tool to trace/measure kernel memory properties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   kvm             Tool to trace/measure kvm guest os</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   list            List all symbolic event types</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   lock            Analyze lock events</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   mem             Profile memory accesses</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   record          Run a command and record its profile into perf.data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   report          Read perf.data (created by perf record) and display the profile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   sched           Tool to trace/measure scheduler properties (latencies)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   script          Read perf.data (created by perf record) and display trace output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   stat            Run a command and gather performance counter statistics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   test            Runs sanity tests.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   timechart       Tool to visualize total system behavior during a workload</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   top             System profiling tool.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   probe           Define new dynamic tracepoints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   trace           strace inspired tool</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> See &#x27;perf help COMMAND&#x27; for more information on a specific command.</span><br></span></code></pre></div></div>
<p>Apart from separate help for each subcommand, there is also documentation in the kernel source under tools/perf/Documentation. perf has evolved, with different functionality added over time, so on an older kernel you may be missing some subcommands or functionality. Also, its usage may not feel consistent as you switch between activities. It&#x27;s best to think of it as a multi-tool.</p>
<p>perf_events can instrument in three ways (now using the perf_events terminology):</p>
<ul>
<li><strong>counting</strong> events in-kernel context, where a summary of counts is printed by perf. This mode does not generate a perf.data file.</li>
<li><strong>sampling</strong> events, which writes event data to a kernel buffer, which is read at a gentle asynchronous rate by the perf command to write to the perf.data file. This file is then read by the perf report or perf script commands.</li>
<li><strong>bpf</strong> programs on events, a new feature in Linux 4.4+ kernels that can execute custom user-defined programs in kernel space, which can perform efficient filters and summaries of the data. Eg, efficiently-measured latency histograms.</li>
</ul>
<p>Try starting by counting events using the perf stat command, to see if this is sufficient. This subcommand costs the least overhead.</p>
<p>When using the sampling mode with perf record, you&#x27;ll need to be a little careful about the overheads, as the capture files can quickly become hundreds of Mbytes. It depends on the rate of the event you are tracing: the more frequent, the higher the overhead and larger the perf.data size.</p>
<p>To really cut down overhead and generate more advanced summaries, write BPF programs executed by perf. See the <a href="https://www.brendangregg.com/#eBPF" target="_blank" rel="noopener noreferrer">eBPF</a> section.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="47-usage-examples">4.7. Usage Examples<a href="#47-usage-examples" class="hash-link" aria-label="4.7. Usage Examples的直接链接" title="4.7. Usage Examples的直接链接" translate="no">​</a></h2>
<p>These example sequences have been chosen to illustrate some different ways that perf is used, from gathering to reporting.</p>
<p>Performance counter summaries, including IPC, for the gzip command:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat gzip largefile</span><br></span></code></pre></div></div>
<p>Count all scheduler process events for 5 seconds, and count by tracepoint:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat -e &#x27;sched:sched_process_*&#x27; -a sleep 5</span><br></span></code></pre></div></div>
<p>Trace all scheduler process events for 5 seconds, and count by both tracepoint and process name:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e &#x27;sched:sched_process_*&#x27; -a sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf report</span><br></span></code></pre></div></div>
<p>Trace all scheduler process events for 5 seconds, and dump per-event details:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e &#x27;sched:sched_process_*&#x27; -a sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span></code></pre></div></div>
<p>Trace read() syscalls, when requested bytes is less than 10:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e &#x27;syscalls:sys_enter_read&#x27; --filter &#x27;count &lt; 10&#x27; -a</span><br></span></code></pre></div></div>
<p>Sample CPU stacks at 99 Hertz, for 5 seconds:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -F 99 -ag -- sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf report</span><br></span></code></pre></div></div>
<p>Dynamically instrument the kernel tcp_sendmsg() function, and trace it for 5 seconds, with stack traces:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe --add tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e probe:tcp_sendmsg -ag -- sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe --del tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf report</span><br></span></code></pre></div></div>
<p>Deleting the tracepoint (--del) wasn&#x27;t necessary; I included it to show how to return the system to its original state.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="caveats">Caveats<a href="#caveats" class="hash-link" aria-label="Caveats的直接链接" title="Caveats的直接链接" translate="no">​</a></h3>
<p>The use of -p PID as a filter doesn&#x27;t work properly on some older kernel versions (Linux 3.x): perf hits 100% CPU and needs to be killed. It&#x27;s annoying. The workaround is to profile all CPUs (-a), and filter PIDs later.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="48-special-usage">4.8. Special Usage<a href="#48-special-usage" class="hash-link" aria-label="4.8. Special Usage的直接链接" title="4.8. Special Usage的直接链接" translate="no">​</a></h2>
<p>There&#x27;s a number of subcommands that provide special purpose functionality. These include:</p>
<ul>
<li><strong>perf c2c</strong> (Linux 4.10+): cache-2-cache and cacheline false sharing analysis.</li>
<li><strong>perf kmem</strong>: kernel memory allocation analysis.</li>
<li><strong>perf kvm</strong>: KVM virtual guest analysis.</li>
<li><strong>perf lock</strong>: lock analysis.</li>
<li><strong>perf mem</strong>: memory access analysis.</li>
<li><strong>perf sched</strong>: kernel scheduler statistics. <a href="https://www.brendangregg.com/#SchedulerAnalysis" target="_blank" rel="noopener noreferrer">Examples</a>.</li>
</ul>
<p>These make use of perf&#x27;s existing instrumentation capabilities, recording selected events and reporting them in custom ways.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-events">5. Events<a href="#5-events" class="hash-link" aria-label="5. Events的直接链接" title="5. Events的直接链接" translate="no">​</a></h2>
<p>perf_events instruments &quot;events&quot;, which are a unified interface for different kernel instrumentation frameworks. The following map (from my <a href="https://www.brendangregg.com/#SCALE13x" target="_blank" rel="noopener noreferrer">SCaLE13x talk</a>) illustrates the event sources:</p>
<p><a href="https://www.brendangregg.com/perf_events/perf_events_map.png" target="_blank" rel="noopener noreferrer"><img decoding="async" loading="lazy" src="/assets/images/12f709784cb5a1c04cda08bf34b06273_MD5-68a8675b57956c884722327f5e80bcc1.png" width="1500" height="1050" class="img_ev3q"></a></p>
<p>The types of events are:</p>
<ul>
<li><strong>Hardware Events</strong>: CPU performance monitoring counters.</li>
<li><strong>Software Events</strong>: These are low level events based on kernel counters. For example, CPU migrations, minor faults, major faults, etc.</li>
<li><strong>Kernel Tracepoint Events</strong>: This are static kernel-level instrumentation points that are hardcoded in interesting and logical places in the kernel.</li>
<li><strong>User Statically-Defined Tracing (USDT)</strong>: These are static tracepoints for user-level programs and applications.</li>
<li><strong>Dynamic Tracing</strong>: Software can be dynamically instrumented, creating events in any location. For kernel software, this uses the kprobes framework. For user-level software, uprobes.</li>
<li><strong>Timed Profiling</strong>: Snapshots can be collected at an arbitrary frequency, using perf record -F <em>Hz</em>. This is commonly used for CPU usage profiling, and works by creating custom timed interrupt events.</li>
</ul>
<p>Details about the events can be collected, including timestamps, the code path that led to it, and other specific details. The capabilities of perf_events are enormous, and you&#x27;re likely to only ever use a fraction.</p>
<p>Currently available events can be listed using the list subcommand:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List of pre-defined events (to be used in -e):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-cycles OR cycles                               [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  instructions                                       [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cache-references                                   [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cache-misses                                       [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-instructions OR branches                    [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-misses                                      [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bus-cycles                                         [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stalled-cycles-frontend OR idle-cycles-frontend    [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stalled-cycles-backend OR idle-cycles-backend      [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ref-cycles                                         [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-clock                                          [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  task-clock                                         [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  page-faults OR faults                              [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  context-switches OR cs                             [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-migrations OR migrations                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  minor-faults                                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  major-faults                                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alignment-faults                                   [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  emulation-faults                                   [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-loads                                    [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-load-misses                              [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-stores                                   [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  rNNN                                               [Raw hardware event descriptor]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu/t1=v1[,t2=v2,t3 ...]/modifier                  [Raw hardware event descriptor]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (see &#x27;man perf-list&#x27; on how to encode it)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mem:&lt;addr&gt;[:access]                                [Hardware breakpoint]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  probe:tcp_sendmsg                                  [Tracepoint event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sched:sched_process_exec                           [Tracepoint event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sched:sched_process_fork                           [Tracepoint event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sched:sched_process_wait                           [Tracepoint event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sched:sched_wait_task                              [Tracepoint event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sched:sched_process_exit                           [Tracepoint event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf list | wc -l</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     657</span><br></span></code></pre></div></div>
<p>When you use dynamic tracing, you are extending this list. The probe<!-- -->:tcp<!-- -->_sendmsg tracepoint in this list is an example, which I added by instrumenting tcp_sendmsg(). Profiling (sampling) events are not listed.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="51-software-events">5.1. Software Events<a href="#51-software-events" class="hash-link" aria-label="5.1. Software Events的直接链接" title="5.1. Software Events的直接链接" translate="no">​</a></h2>
<p>There is a small number of fixed software events provided by perf:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List of pre-defined events (to be used in -e):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alignment-faults                                   [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bpf-output                                         [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  context-switches OR cs                             [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-clock                                          [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-migrations OR migrations                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dummy                                              [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  emulation-faults                                   [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  major-faults                                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  minor-faults                                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  page-faults OR faults                              [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  task-clock                                         [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>These are also documented in the man page perf_event_open(2):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   PERF_COUNT_SW_CPU_CLOCK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          This reports the CPU clock, a  high-resolution  per-</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          CPU timer.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   PERF_COUNT_SW_TASK_CLOCK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          This reports a clock count specific to the task that</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          is running.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   PERF_COUNT_SW_PAGE_FAULTS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          This reports the number of page faults.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   PERF_COUNT_SW_CONTEXT_SWITCHES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          This counts context switches.  Until  Linux  2.6.34,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          these  were all reported as user-space events, after</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          that they are reported as happening in the kernel.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   PERF_COUNT_SW_CPU_MIGRATIONS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          This reports the number of  times  the  process  has</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          migrated to a new CPU.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   PERF_COUNT_SW_PAGE_FAULTS_MIN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          This  counts the number of minor page faults.  These</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          did not require disk I/O to handle.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>The kernel also supports <a href="https://www.brendangregg.com/#Tracepoints" target="_blank" rel="noopener noreferrer">traecpoints</a>, which are very similar to software events, but have a different more extensible API.</p>
<p>Software events may have a default period. This means that when you use them for sampling, you&#x27;re sampling a subset of events, not tracing every event. You can check with perf record -vv:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -vv -e context-switches /bin/true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Using CPUID GenuineIntel-6-55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf_event_attr:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  type                             1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  size                             112</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  config                           0x3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  { sample_period, sample_freq }   4000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sample_type                      IP|TID|TIME|PERIOD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  disabled                         1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  inherit                          1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mmap                             1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  comm                             1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  freq                             1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  enable_on_exec                   1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>See the perf_event_open(2) man page for a description of these fields. This default means is that the kernel adjusts the rate of sampling so that it&#x27;s capturing about 4,000 context switch events per second. If you really meant to record them all, use -c 1:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -vv -e context-switches -c 1 /bin/true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Using CPUID GenuineIntel-6-55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf_event_attr:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  type                             1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  size                             112</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  config                           0x3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  { sample_period, sample_freq }   1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sample_type                      IP|TID|TIME</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  disabled                         1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  inherit                          1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mmap                             1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  comm                             1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  enable_on_exec                   1</span><br></span></code></pre></div></div>
<p>Check the rate of events using perf stat first, so that you can estimate the volume of data you&#x27;ll be capturing. Sampling a subset by default may be a good thing, especially for high frequency events like context switches.</p>
<p>Many other events (like tracepoints) have a default of 1 anyway. You&#x27;ll encounter a non-1 default for many software and hardware events.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="52-hardware-events-pmcs">5.2. Hardware Events (PMCs)<a href="#52-hardware-events-pmcs" class="hash-link" aria-label="5.2. Hardware Events (PMCs)的直接链接" title="5.2. Hardware Events (PMCs)的直接链接" translate="no">​</a></h2>
<p>perf_events began life as a tool for instrumenting the processor&#x27;s performance monitoring unit (PMU) hardware counters, also called performance monitoring counters (PMCs), or performance instrumentation counters (PICs). These instrument low-level processor activity, for example, CPU cycles, instructions retired, memory stall cycles, level 2 cache misses, etc. Some will be listed as Hardware Cache Events.</p>
<p>PMCs are documented in the <em>Intel 64 and IA-32 Architectures Software Developer&#x27;s Manual Volume 3B: System Programming Guide, Part 2</em> and the <em>BIOS and Kernel Developer&#x27;s Guide (BKDG) For AMD Family 10h Processors</em>. There are thousands of different PMCs available.</p>
<p>A typical processor will implement PMCs in the following way: only a few or several can be recorded at the same time, from the many thousands that are available. This is because they are a fixed hardware resource on the processor (a limited number of registers), and are programmed to begin counting the selected events.</p>
<p>For examples of using PMCs, see <a href="https://www.brendangregg.com/#CPUstatistics" target="_blank" rel="noopener noreferrer">CPU Statistics</a>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="53-kernel-tracepoints">5.3. Kernel Tracepoints<a href="#53-kernel-tracepoints" class="hash-link" aria-label="5.3. Kernel Tracepoints的直接链接" title="5.3. Kernel Tracepoints的直接链接" translate="no">​</a></h2>
<p>These tracepoints are hard coded in interesting and logical locations of the kernel, so that higher-level behavior can be easily traced. For example, system calls, TCP events, file system I/O, disk I/O, etc. These are grouped into libraries of tracepoints; eg, &quot;sock:&quot; for socket events, &quot;sched:&quot; for CPU scheduler events. A key value of tracepoints is that they should have a stable API, so if you write tools that use them on one kernel version, they should work on later versions as well.</p>
<p>Tracepoints are usually added to kernel code by placing a macro from include/trace/events/*. XXX cover implementation.</p>
<p>Summarizing the tracepoint library names and numbers of tracepoints, on my Linux 4.10 system:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf list | awk -F: &#x27;/Tracepoint event/ { lib[$1]++ } END {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (l in lib) { printf &quot;  %-16.16s %d\n&quot;, l, lib[l] } }&#x27; | sort | column</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alarmtimer     4        i2c            8        page_isolation 1        swiotlb        1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block          19        iommu          7        pagemap        2        syscalls       614</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    btrfs          51        irq            5        power          22        task           2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cgroup         9        irq_vectors    22        printk         1        thermal        7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clk            14        jbd2           16        random         15        thermal_power_ 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cma            2        kmem           12        ras            4        timer          13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    compaction     14        libata         6        raw_syscalls   2        tlb            1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cpuhp          3        mce            1        rcu            1        udp            1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dma_fence      8        mdio           1        regmap         15        vmscan         15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    exceptions     2        migrate        2        regulator      7        vsyscall       1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ext4           95        mmc            2        rpm            4        workqueue      4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fib            3        module         5        sched          24        writeback      30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fib6           1        mpx            5        scsi           5        x86_fpu        14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    filelock       10        msr            3        sdt_node       1        xen            35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    filemap        2        napi           1        signal         2        xfs            495</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ftrace         1        net            10        skb            3        xhci-hcd       9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gpio           2        nmi            1        sock           2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    huge_memory    4        oom            1        spi            7</span><br></span></code></pre></div></div>
<p>These include:</p>
<ul>
<li><strong>block</strong>: block device I/O</li>
<li><strong>ext4</strong>: file system operations</li>
<li><strong>kmem</strong>: kernel memory allocation events</li>
<li><strong>random</strong>: kernel random number generator events</li>
<li><strong>sched</strong>: CPU scheduler events</li>
<li><strong>syscalls</strong>: system call enter and exits</li>
<li><strong>task</strong>: task events</li>
</ul>
<p>It&#x27;s worth checking the list of tracepoints after every kernel upgrade, to see if any are new. The value of adding them <a href="http://lwn.net/Articles/346470/" target="_blank" rel="noopener noreferrer">has been</a> <a href="http://lwn.net/Articles/346483/" target="_blank" rel="noopener noreferrer">debated</a> from time to time, with it wondered how many people will use them (I do). There is a balance to aim for: I&#x27;d include the smallest number of probes that sufficiently covers common needs, and anything unusual or uncommon can be left to dynamic tracing.</p>
<p>For examples of using tracepoints, see <a href="https://www.brendangregg.com/#StaticKernelTracing" target="_blank" rel="noopener noreferrer">Static Kernel Tracing</a>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="54-user-level-statically-defined-tracing-usdt">5.4. User-Level Statically Defined Tracing (USDT)<a href="#54-user-level-statically-defined-tracing-usdt" class="hash-link" aria-label="5.4. User-Level Statically Defined Tracing (USDT)的直接链接" title="5.4. User-Level Statically Defined Tracing (USDT)的直接链接" translate="no">​</a></h2>
<p>Similar to kernel tracepoints, these are hardcoded (usually by placing macros) in the application source at logical and interesting locations, and presented (event name and arguments) as a stable API. Many applications already include tracepoints, added to support <a href="https://www.brendangregg.com/dtrace.html" target="_blank" rel="noopener noreferrer">DTrace</a>. However, many of these applications do not compile them in by default on Linux. Often you need to compile the application yourself using a --with-dtrace flag.</p>
<p>For example, compiling USDT events with this version of Node.js:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ sudo apt-get install systemtap-sdt-dev       # adds &quot;dtrace&quot;, used by node build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ wget https://nodejs.org/dist/v4.4.1/node-v4.4.1.tar.gz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ tar xvf node-v4.4.1.tar.gz </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ cd node-v4.4.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ ./configure --with-dtrace</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ make -j 8</span><br></span></code></pre></div></div>
<p>To check that the resulting node binary has probes included:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ readelf -n node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Displaying notes found at file offset 0x00000254 with length 0x00000020:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Owner                 Data size    Description</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  GNU                  0x00000010    NT_GNU_ABI_TAG (ABI version tag)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    OS: Linux, ABI: 2.6.32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Displaying notes found at file offset 0x00000274 with length 0x00000024:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Owner                 Data size    Description</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  GNU                  0x00000014    NT_GNU_BUILD_ID (unique build ID bitstring)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Build ID: 1e01659b0aecedadf297b2c56c4a2b536ae2308a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Displaying notes found at file offset 0x00e70994 with length 0x000003c4:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Owner                 Data size    Description</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stapsdt              0x0000003c    NT_STAPSDT (SystemTap probe descriptors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Provider: node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Name: gc__start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Location: 0x0000000000dc14e4, Base: 0x000000000112e064, Semaphore: 0x000000000147095c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arguments: 4@%esi 4@%edx 8@%rdi</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stapsdt              0x0000003b    NT_STAPSDT (SystemTap probe descriptors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Provider: node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Name: gc__done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Location: 0x0000000000dc14f4, Base: 0x000000000112e064, Semaphore: 0x000000000147095e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arguments: 4@%esi 4@%edx 8@%rdi</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stapsdt              0x00000067    NT_STAPSDT (SystemTap probe descriptors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Provider: node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Name: http__server__response</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Location: 0x0000000000dc1894, Base: 0x000000000112e064, Semaphore: 0x0000000001470956</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arguments: 8@%rax 8@-1144(%rbp) -4@-1148(%rbp) -4@-1152(%rbp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stapsdt              0x00000061    NT_STAPSDT (SystemTap probe descriptors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Provider: node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Name: net__stream__end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Location: 0x0000000000dc1c44, Base: 0x000000000112e064, Semaphore: 0x0000000001470952</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arguments: 8@%rax 8@-1144(%rbp) -4@-1148(%rbp) -4@-1152(%rbp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stapsdt              0x00000068    NT_STAPSDT (SystemTap probe descriptors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Provider: node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Name: net__server__connection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Location: 0x0000000000dc1ff4, Base: 0x000000000112e064, Semaphore: 0x0000000001470950</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arguments: 8@%rax 8@-1144(%rbp) -4@-1148(%rbp) -4@-1152(%rbp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stapsdt              0x00000060    NT_STAPSDT (SystemTap probe descriptors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Provider: node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Name: http__client__response</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Location: 0x0000000000dc23c5, Base: 0x000000000112e064, Semaphore: 0x000000000147095a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arguments: 8@%rdx 8@-1144(%rbp) -4@%eax -4@-1152(%rbp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stapsdt              0x00000089    NT_STAPSDT (SystemTap probe descriptors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Provider: node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Name: http__client__request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Location: 0x0000000000dc285e, Base: 0x000000000112e064, Semaphore: 0x0000000001470958</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arguments: 8@%rax 8@%rdx 8@-2184(%rbp) -4@-2188(%rbp) 8@-2232(%rbp) 8@-2240(%rbp) -4@-2192(%rbp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stapsdt              0x00000089    NT_STAPSDT (SystemTap probe descriptors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Provider: node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Name: http__server__request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Location: 0x0000000000dc2e69, Base: 0x000000000112e064, Semaphore: 0x0000000001470954</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arguments: 8@%r14 8@%rax 8@-4344(%rbp) -4@-4348(%rbp) 8@-4304(%rbp) 8@-4312(%rbp) -4@-4352(%rbp)</span><br></span></code></pre></div></div>
<p>For examples of using USDT events, see <a href="https://www.brendangregg.com/#StaticUserTracing" target="_blank" rel="noopener noreferrer">Static User Tracing</a>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="55-dynamic-tracing">5.5. Dynamic Tracing<a href="#55-dynamic-tracing" class="hash-link" aria-label="5.5. Dynamic Tracing的直接链接" title="5.5. Dynamic Tracing的直接链接" translate="no">​</a></h2>
<p>The difference between tracepoints and dynamic tracing is shown in the following figure, which illustrates the coverage of common tracepoint libraries:</p>
<p><img decoding="async" loading="lazy" src="/assets/images/ce071b31b321a8d9d927c1d4254216a4_MD5-9f64bb07ac6ab3d6f11341c172cb745c.png" width="1700" height="516" class="img_ev3q"></p>
<p>While dynamic tracing can see everything, it&#x27;s also an unstable interface since it is instrumenting raw code. That means that any dynamic tracing tools you develop may break after a kernel patch or update. Try to use the static tracepoints first, since their interface should be much more stable. They can also be easier to use and understand, since they have been designed with a tracing end-user in mind.</p>
<p>One benefit of dynamic tracing is that it can be enabled on a live system without restarting anything. You can take an already-running kernel or application and then begin dynamic instrumentation, which (safely) patches instructions in memory to add instrumentation. That means there is zero overhead or tax for this feature until you begin using it. One moment your binary is running unmodified and at full speed, and the next, it&#x27;s running some extra instrumentation instructions that you dynamically added. Those instructions should eventually be removed once you&#x27;ve finished using your session of dynamic tracing.</p>
<p>The overhead while dynamic tracing is in use, and extra instructions are being executed, is relative to the frequency of instrumented events multiplied by the work done on each instrumentation.</p>
<p>For examples of using dynamic tracing, see <a href="https://www.brendangregg.com/#DynamicTracingEg" target="_blank" rel="noopener noreferrer">6.5. Dynamic Tracing</a>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-examples">6. Examples<a href="#6-examples" class="hash-link" aria-label="6. Examples的直接链接" title="6. Examples的直接链接" translate="no">​</a></h2>
<p>These are some examples of perf_events, collected from a variety of 3.x Linux systems.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="61-cpu-statistics">6.1. CPU Statistics<a href="#61-cpu-statistics" class="hash-link" aria-label="6.1. CPU Statistics的直接链接" title="6.1. CPU Statistics的直接链接" translate="no">​</a></h2>
<p>The perf stat command instruments and summarizes key CPU counters (PMCs). This is from perf version 3.5.7.2:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat gzip file1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Performance counter stats for &#x27;gzip file1&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1920.159821 task-clock                #    0.991 CPUs utilized          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                13 context-switches          #    0.007 K/sec                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 0 CPU-migrations            #    0.000 K/sec                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               258 page-faults               #    0.134 K/sec                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     5,649,595,479 cycles                    #    2.942 GHz                     [83.43%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,808,339,931 stalled-cycles-frontend   #   32.01% frontend cycles idle    [83.54%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,171,884,577 stalled-cycles-backend    #   20.74% backend  cycles idle    [66.77%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     8,625,207,199 instructions              #    1.53  insns per cycle        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             #    0.21  stalled cycles per insn [83.51%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,488,797,176 branches                  #  775.351 M/sec                   [82.58%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        53,395,139 branch-misses             #    3.59% of all branches         [83.78%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1.936842598 seconds time elapsed</span><br></span></code></pre></div></div>
<p>This includes instructions per cycle (IPC), labled &quot;insns per cycle&quot;, or in earlier versions, &quot;IPC&quot;. This is a commonly examined metric, either IPC or its invert, CPI. Higher IPC values mean higher instruction throughput, and lower values indicate more stall cycles. I&#x27;d generally interpret high IPC values (eg, over 1.0) as good, indicating optimal processing of work. However, I&#x27;d want to double check what the instructions are, in case this is due to a spin loop: a high rate of instructions, but a low rate of actual work completed.</p>
<p>There are some advanced metrics now included in perf stat: frontend cycles idle, backend cycles idle, and stalled cycles per insn. To really understand these, you&#x27;ll need some knowledge of CPU microarchitecture.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cpu-microarchitecture">CPU Microarchitecture<a href="#cpu-microarchitecture" class="hash-link" aria-label="CPU Microarchitecture的直接链接" title="CPU Microarchitecture的直接链接" translate="no">​</a></h3>
<p>The frontend and backend metrics refer to the CPU pipeline, and are also based on stall counts. The frontend processes CPU instructions, in order. It involves instruction fetch, along with branch prediction, and decode. The decoded instructions become micro-operations (uops) which the backend processes, and it may do so out of order. For a longer summary of these components, see Shannon Cepeda&#x27;s great posts on <a href="http://software.intel.com/en-us/blogs/2011/11/22/pipeline-speak-learning-more-about-intel-microarchitecture-codename-sandy-bridge" target="_blank" rel="noopener noreferrer">frontend</a> and <a href="http://software.intel.com/en-us/blogs/2011/12/01/pipeline-speak-part-2-the-second-part-of-the-sandy-bridge-pipeline" target="_blank" rel="noopener noreferrer">backend</a>.</p>
<p>The backend can also process multiple uops in parallel; for modern processors, three or four. Along with pipelining, this is how IPC can become greater than one, as more than one instruction can be completed (&quot;retired&quot;) per CPU cycle.</p>
<p>Stalled cycles per instruction is similar to IPC (inverted), however, only counting stalled cycles, which will be for memory or resource bus access. This makes it easy to interpret: stalls are latency, reduce stalls. I really like it as a metric, and hope it becomes as commonplace as IPC/CPI. Lets call it SCPI.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="detailed-mode">Detailed Mode<a href="#detailed-mode" class="hash-link" aria-label="Detailed Mode的直接链接" title="Detailed Mode的直接链接" translate="no">​</a></h3>
<p>There is a &quot;detailed&quot; mode for perf stat:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat -d gzip file1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Performance counter stats for &#x27;gzip file1&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1610.719530 task-clock                #    0.998 CPUs utilized          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                20 context-switches          #    0.012 K/sec                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 0 CPU-migrations            #    0.000 K/sec                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               258 page-faults               #    0.160 K/sec                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     5,491,605,997 cycles                    #    3.409 GHz                     [40.18%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,654,551,151 stalled-cycles-frontend   #   30.13% frontend cycles idle    [40.80%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,025,280,350 stalled-cycles-backend    #   18.67% backend  cycles idle    [40.34%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     8,644,643,951 instructions              #    1.57  insns per cycle        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             #    0.19  stalled cycles per insn [50.89%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,492,911,665 branches                  #  926.860 M/sec                   [50.69%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        53,471,580 branch-misses             #    3.58% of all branches         [51.21%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,938,889,736 L1-dcache-loads           # 1203.741 M/sec                   [49.68%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       154,380,395 L1-dcache-load-misses     #    7.96% of all L1-dcache hits   [49.66%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 0 LLC-loads                 #    0.000 K/sec                   [39.27%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 0 LLC-load-misses           #    0.00% of all LL-cache hits    [39.61%]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1.614165346 seconds time elapsed</span><br></span></code></pre></div></div>
<p>This includes additional counters for Level 1 data cache events, and last level cache (LLC) events.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="specific-counters">Specific Counters<a href="#specific-counters" class="hash-link" aria-label="Specific Counters的直接链接" title="Specific Counters的直接链接" translate="no">​</a></h3>
<p>Hardware cache event counters, seen in perf list, can be instrumented. Eg:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf list | grep L1-dcache</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-loads                                    [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-load-misses                              [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-stores                                   [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-store-misses                             [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-prefetches                               [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-prefetch-misses                          [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores gzip file1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Performance counter stats for &#x27;gzip file1&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,947,551,657 L1-dcache-loads</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       153,829,652 L1-dcache-misses</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         #    7.90% of all L1-dcache hits  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1,171,475,286 L1-dcache-stores</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1.538038091 seconds time elapsed</span><br></span></code></pre></div></div>
<p>The percentage printed is a convenient calculation that perf_events has included, based on the counters I specified. If you include the &quot;cycles&quot; and &quot;instructions&quot; counters, it will include an IPC calculation in the output.</p>
<p>These hardware events that can be measured are often specific to the processor model. Many may not be available from within a virtualized environment.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="raw-counters">Raw Counters<a href="#raw-counters" class="hash-link" aria-label="Raw Counters的直接链接" title="Raw Counters的直接链接" translate="no">​</a></h3>
<p>The <em>Intel 64 and IA-32 Architectures Software Developer&#x27;s Manual Volume 3B: System Programming Guide, Part 2</em> and the <em>BIOS and Kernel Developer&#x27;s Guide (BKDG) For AMD Family 10h Processors</em> are full of interesting counters, but most cannot be found in perf list. If you find one you want to instrument, you can specify it as a raw event with the format: rUUEE, where UU == umask, and EE == event number. Here&#x27;s an example where I&#x27;ve added a couple of raw counters:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat -e cycles,instructions,r80a2,r2b1 gzip file1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Performance counter stats for &#x27;gzip file1&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     5,586,963,328 cycles                    #    0.000 GHz                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     8,608,237,932 instructions              #    1.54  insns per cycle        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         9,448,159 raw 0x80a2                                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11,855,777,803 raw 0x2b1                                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1.588618969 seconds time elapsed</span><br></span></code></pre></div></div>
<p>If I did this right, then r80a2 has instrumented RESOURCE_STALLS.OTHER, and r2b1 has instrumented UOPS_DISPATCHED.CORE: the number of uops dispatched each cycle. It&#x27;s easy to mess this up, and you&#x27;ll want to double check that you are on the right page of the manual for your processor.</p>
<p>If you do find an awesome raw counter, please <a href="http://dir.gmane.org/gmane.linux.kernel.perf.user" target="_blank" rel="noopener noreferrer">suggest</a> it be added as an alias in perf_events, so we all can find it in perf list.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="other-options">Other Options<a href="#other-options" class="hash-link" aria-label="Other Options的直接链接" title="Other Options的直接链接" translate="no">​</a></h3>
<p>The perf subcommands, especially perf stat, have an extensive option set which can be listed using &quot;-h&quot;. I&#x27;ve included the full output for perf stat here from version 3.9.3, not as a reference, but as an illustration of the interface:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat -h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usage: perf stat [&lt;options&gt;] [&lt;command&gt;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -e, --event &lt;event&gt;   event selector. use &#x27;perf list&#x27; to list available events</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        --filter &lt;filter&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          event filter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -i, --no-inherit      child tasks do not inherit counters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -p, --pid &lt;pid&gt;       stat events on existing process id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -t, --tid &lt;tid&gt;       stat events on existing thread id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -a, --all-cpus        system-wide collection from all CPUs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -g, --group           put the counters into a counter group</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -c, --scale           scale/normalize counters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -v, --verbose         be more verbose (show counter open errors, etc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -r, --repeat &lt;n&gt;      repeat command and print average + stddev (max: 100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -n, --null            null run - dont start any counters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -d, --detailed        detailed run - start a lot of events</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -S, --sync            call sync() before starting a run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -B, --big-num         print large numbers with thousands&#x27; separators</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -C, --cpu &lt;cpu&gt;       list of cpus to monitor in system-wide</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -A, --no-aggr         disable CPU count aggregation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -x, --field-separator &lt;separator&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          print counts with custom separator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -G, --cgroup &lt;name&gt;   monitor event in cgroup name only</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -o, --output &lt;file&gt;   output file name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        --append          append to the output file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        --log-fd &lt;n&gt;      log output to fd, instead of stderr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        --pre &lt;command&gt;   command to run prior to the measured command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        --post &lt;command&gt;  command to run after to the measured command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -I, --interval-print &lt;n&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          print counts at regular interval in ms (&gt;= 100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        --aggr-socket     aggregate counts per processor socket</span><br></span></code></pre></div></div>
<p>Options such as --repeat, --sync, --pre, and --post can be quite useful when doing automated testing or micro-benchmarking.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="62-timed-profiling">6.2. Timed Profiling<a href="#62-timed-profiling" class="hash-link" aria-label="6.2. Timed Profiling的直接链接" title="6.2. Timed Profiling的直接链接" translate="no">​</a></h2>
<p>perf_events can profile CPU usage based on sampling the instruction pointer or stack trace at a fixed interval (timed profiling).</p>
<p>Sampling CPU stacks at 99 Hertz (-F 99), for the entire system (-a, for all CPUs), with stack traces (-g, for call graphs), for 10 seconds:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -F 99 -a -g -- sleep 30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Woken up 9 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 3.135 MB perf.data (~136971 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ls -lh perf.data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw------- 1 root root 3.2M Jan 26 07:26 perf.data</span><br></span></code></pre></div></div>
<p>The choice of 99 Hertz, instead of 100 Hertz, is to avoid accidentally sampling in lockstep with some periodic activity, which would produce skewed results. This is also coarse: you may want to increase that to higher rates (eg, up to 997 Hertz) for finer resolution, especially if you are sampling short bursts of activity and you&#x27;d still like enough resolution to be useful. Bear in mind that higher frequencies means higher overhead.</p>
<p>The perf.data file can be processed in a variety of ways. On recent versions, the perf report command launches an ncurses navigator for call graph inspection. Older versions of perf (or if you use --stdio in the new version) print the call graph as a tree, annotated with percentages:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf report --stdio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># captured on: Mon Jan 26 07:26:40 2014</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># hostname : dev2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># os release : 3.8.6-ubuntu-12-opt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf version : 3.8.6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># arch : x86_64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus online : 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus avail : 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpudesc : Intel(R) Xeon(R) CPU X5675 @ 3.07GHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpuid : GenuineIntel,6,44,2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># total memory : 8182008 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cmdline : /usr/bin/perf record -F 99 -a -g -- sleep 30 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = cpu-clock, type = 1, config = 0x0, config1 = 0x0, config2 = ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_CPU_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_NUMA_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># pmu mappings: software = 1, breakpoint = 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Samples: 22K of event &#x27;cpu-clock&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Event count (approx.): 22751</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Overhead  Command      Shared Object                           Symbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ........  .......  .................  ...............................</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    94.12%       dd  [kernel.kallsyms]  [k] _raw_spin_unlock_irqrestore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 --- _raw_spin_unlock_irqrestore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |--96.67%-- extract_buf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          extract_entropy_user</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          urandom_read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          vfs_read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          sys_read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          system_call_fastpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |--1.69%-- account</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          |--99.72%-- extract_entropy_user</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          |          urandom_read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          |          vfs_read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          |          sys_read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          |          system_call_fastpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          |          read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |           --0.28%-- [...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |--1.60%-- mix_pool_bytes.constprop.17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>This tree starts with the on-CPU functions and works back through the ancestry. This approach is called a &quot;callee based call graph&quot;. This can be flipped by using -G for an &quot;inverted call graph&quot;, or by using the &quot;caller&quot; option to -g/--call-graph, instead of the &quot;callee&quot; default.</p>
<p>The hottest (most frequent) stack trace in this perf call graph occurred in 90.99% of samples, which is the product of the overhead percentage and top stack leaf (94.12% x 96.67%, which are relative rates). perf report can also be run with &quot;-g graph&quot; to show absolute overhead rates, in which case &quot;90.99%&quot; is directly displayed on the stack leaf:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">94.12%       dd  [kernel.kallsyms]  [k] _raw_spin_unlock_irqrestore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 --- _raw_spin_unlock_irqrestore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    |--90.99%-- extract_buf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>If user-level stacks look incomplete, you can try perf record with &quot;--call-graph dwarf&quot; as a different technique to unwind them. See the <a href="https://www.brendangregg.com/#StackTraces" target="_blank" rel="noopener noreferrer">Stacks</a> section.</p>
<p>The output from perf report can be many pages long, which can become cumbersome to read. Try generating <a href="https://www.brendangregg.com/#FlameGraphs" target="_blank" rel="noopener noreferrer">Flame Graphs</a> from the same data.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="63-event-profiling">6.3. Event Profiling<a href="#63-event-profiling" class="hash-link" aria-label="6.3. Event Profiling的直接链接" title="6.3. Event Profiling的直接链接" translate="no">​</a></h2>
<p>Apart from sampling at a timed interval, taking samples triggered by CPU hardware counters is another form of CPU profiling, which can be used to shed more light on cache misses, memory stall cycles, and other low-level processor events. The available events can be found using perf list:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf list | grep Hardware</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-cycles OR cycles                               [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  instructions                                       [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cache-references                                   [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cache-misses                                       [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-instructions OR branches                    [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-misses                                      [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bus-cycles                                         [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stalled-cycles-frontend OR idle-cycles-frontend    [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  stalled-cycles-backend OR idle-cycles-backend      [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ref-cycles                                         [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-loads                                    [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-load-misses                              [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-stores                                   [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-store-misses                             [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>For many of these, gathering a stack on every occurrence would induce far too much overhead, and would slow down the system and change the performance characteristics of the target. It&#x27;s usually sufficient to only instrument a small fraction of their occurrences, rather than all of them. This can be done by specifying a threshold for triggering event collection, using &quot;-c&quot; and a count.</p>
<p>For example, the following one-liner instruments Level 1 data cache load misses, collecting a stack trace for one in every 10,000 occurrences:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e L1-dcache-load-misses -c 10000 -ag -- sleep 5</span><br></span></code></pre></div></div>
<p>The mechanics of &quot;-c count&quot; are implemented by the processor, which only interrupts the kernel when the threshold has been reached.</p>
<p>See the earlier Raw Counters section for an example of specifying a custom counter, and the next section about skew.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="skew-and-pebs">Skew and PEBS<a href="#skew-and-pebs" class="hash-link" aria-label="Skew and PEBS的直接链接" title="Skew and PEBS的直接链接" translate="no">​</a></h3>
<p>There&#x27;s a problem with event profiling that you don&#x27;t really encounter with CPU profiling (timed sampling). With timed sampling, it doesn&#x27;t matter if there was a small sub-microsecond delay between the interrupt and reading the instruction pointer (IP). Some CPU profilers introduce this jitter on purpose, as another way to avoid lockstep sampling. But for event profiling, it does matter: if you&#x27;re trying to capture the IP on some PMC event, and there&#x27;s a delay between the PMC overflow and capturing the IP, then the IP will point to the wrong address. This is skew. Another contributing problem is that micro-ops are processed in parallel and out-of-order, while the instruction pointer points to the resumption instruction, not the instruction that caused the event. I&#x27;ve talked about this <a href="https://www.slideshare.net/brendangregg/scale2015-linux-perfprofiling/63" target="_blank" rel="noopener noreferrer">before</a>.</p>
<p>The solution is &quot;precise sampling&quot;, which on Intel is PEBS (Precise Event-Based Sampling), and on AMD it is IBS (Instruction-Based Sampling). These use CPU hardware support to capture the real state of the CPU at the time of the event. perf can use precise sampling by adding a<!-- -->:p<!-- --> modifier to the PMC event name, eg, &quot;-e instructions<!-- -->:p<!-- -->&quot;. The more p&#x27;s, the more accurate. Here are the docs from <a href="https://github.com/torvalds/linux/blob/master/tools/perf/Documentation/perf-list.txt" target="_blank" rel="noopener noreferrer">tools/perf/Documentation/perf-list.txt</a>:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">The &#x27;p&#x27; modifier can be used for specifying how precise the instruction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address should be. The &#x27;p&#x27; modifier can be specified multiple times:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 0 - SAMPLE_IP can have arbitrary skid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1 - SAMPLE_IP must have constant skid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 - SAMPLE_IP requested to have 0 skid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 - SAMPLE_IP must have 0 skid</span><br></span></code></pre></div></div>
<p>In some cases, perf will default to using precise sampling without you needing to specify it. Run &quot;perf record -vv...&quot; to see the value of &quot;precise_ip&quot;. Also note that only some PMCs support PEBS.</p>
<p>If PEBS isn&#x27;t working at all for you, check dmesg:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># dmesg | grep -i pebs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[    0.387014] Performance Events: PEBS fmt1+, SandyBridge events, 16-deep LBR, full-width counters, Intel PMU driver.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[    0.387034] core: PEBS disabled due to CPU errata, please upgrade microcode</span><br></span></code></pre></div></div>
<p>The fix (on Intel):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># apt-get install -y intel-microcode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">intel-microcode: microcode will be updated at next boot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Processing triggers for initramfs-tools (0.125ubuntu5) ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">update-initramfs: Generating /boot/initrd.img-4.8.0-41-generic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># reboot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(system reboots)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># dmesg | grep -i pebs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[    0.386596] Performance Events: PEBS fmt1+, SandyBridge events, 16-deep LBR, full-width counters, Intel PMU driver.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span></code></pre></div></div>
<p>XXX: Need to cover more PEBS problems and other caveats.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="64-static-kernel-tracing">6.4. Static Kernel Tracing<a href="#64-static-kernel-tracing" class="hash-link" aria-label="6.4. Static Kernel Tracing的直接链接" title="6.4. Static Kernel Tracing的直接链接" translate="no">​</a></h2>
<p>The following examples demonstrate static tracing: the instrumentation of tracepoints and other static events.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="counting-syscalls">Counting Syscalls<a href="#counting-syscalls" class="hash-link" aria-label="Counting Syscalls的直接链接" title="Counting Syscalls的直接链接" translate="no">​</a></h3>
<p>The following simple one-liner counts system calls for the executed command, and prints a summary (of non-zero counts):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat -e &#x27;syscalls:sys_enter_*&#x27; gzip file1 2&gt;&amp;1 | awk &#x27;$1 != 0&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Performance counter stats for &#x27;gzip file1&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_utimensat               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_unlink                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 5 syscalls:sys_enter_newfstat                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             1,603 syscalls:sys_enter_read                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             3,201 syscalls:sys_enter_write                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 5 syscalls:sys_enter_access                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_fchmod                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_fchown                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 6 syscalls:sys_enter_open                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 9 syscalls:sys_enter_close                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 8 syscalls:sys_enter_mprotect                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_brk                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_munmap                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_set_robust_list         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_futex                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_getrlimit               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 5 syscalls:sys_enter_rt_sigprocmask          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                14 syscalls:sys_enter_rt_sigaction            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_exit_group              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 1 syscalls:sys_enter_set_tid_address         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                14 syscalls:sys_enter_mmap                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1.543990940 seconds time elapsed</span><br></span></code></pre></div></div>
<p>In this case, a gzip command was analyzed. The report shows that there were 3,201 write() syscalls, and half that number of read() syscalls. Many of the other syscalls will be due to process and library initialization.</p>
<p>A similar report can be seen using strace -c, the system call tracer, however it may induce much higher overhead than perf, as perf buffers data in-kernel.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="perf-vs-strace">perf vs strace<a href="#perf-vs-strace" class="hash-link" aria-label="perf vs strace的直接链接" title="perf vs strace的直接链接" translate="no">​</a></h3>
<p>To explain the difference a little further: the current implementation of strace uses ptrace(2) to attach to the target process and stop it during system calls, like a debugger. This is violent, and can cause serious overhead. To demonstrate this, the following syscall-heavy program was run by itself, with perf, and with strace. I&#x27;ve only included the line of output that shows its performance:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># dd if=/dev/zero of=/dev/null bs=512 count=10000k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5242880000 bytes (5.2 GB) copied, 3.53031 s, 1.5 GB/s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf stat -e &#x27;syscalls:sys_enter_*&#x27; dd if=/dev/zero of=/dev/null bs=512 count=10000k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5242880000 bytes (5.2 GB) copied, 9.14225 s, 573 MB/s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># strace -c dd if=/dev/zero of=/dev/null bs=512 count=10000k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5242880000 bytes (5.2 GB) copied, 218.915 s, 23.9 MB/s</span><br></span></code></pre></div></div>
<p>With perf, the program ran 2.5x slower. But <strong>with strace, it ran 62x slower</strong>. That&#x27;s likely to be a worst-case result: if syscalls are not so frequent, the difference between the tools will not be as great.</p>
<p>Recent version of perf have included a trace subcommand, to provide some similar functionality to strace, but with much lower overhead.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="new-processes">New Processes<a href="#new-processes" class="hash-link" aria-label="New Processes的直接链接" title="New Processes的直接链接" translate="no">​</a></h3>
<p>Tracing new processes triggered by a &quot;man ls&quot;:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e sched:sched_process_exec -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.064 MB perf.data (~2788 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf report -n --sort comm --stdio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Overhead       Samples  Command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ........  ............  .......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1    troff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1      tbl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1  preconv</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1    pager</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1    nroff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1      man</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1   locale</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1   grotty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    11.11%             1    groff</span><br></span></code></pre></div></div>
<p>Nine different commands were executed, each once. I used -n to print the &quot;Samples&quot; column, and &quot;--sort comm&quot; to customize the remaining columns.</p>
<p>This works by tracing sched<!-- -->:sched<!-- -->_process_exec, when a process runs exec() to execute a different binary. This is often how new processes are created, but not always. An application may fork() to create a pool of worker processes, but not exec() a different binary. An application may also reexec: call exec() again, on itself, usually to clean up its address space. In that case, it&#x27;s will be seen by this exec tracepoint, but it&#x27;s not a new process.</p>
<p>The sched<!-- -->:sched<!-- -->_process_fork tracepoint can be traced to only catch new processes, created via fork(). The downside is that the process identified is the parent, not the new target, as the new process has yet to exec() it&#x27;s final program.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="outbound-connections">Outbound Connections<a href="#outbound-connections" class="hash-link" aria-label="Outbound Connections的直接链接" title="Outbound Connections的直接链接" translate="no">​</a></h3>
<p>There can be times when it&#x27;s useful to double check what network connections are initiated by a server, from which processes, and why. You might be surprised. These connections can be important to understand, as they can be a source of latency.</p>
<p>For this example, I have a completely idle ubuntu server, and while tracing I&#x27;ll login to it using ssh. I&#x27;m going to trace outbound connections via the connect() syscall. Given that I&#x27;m performing an <em>inbound</em> connection over SSH, will there be any outbound connections at all?</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e syscalls:sys_enter_connect -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.057 MB perf.data (~2489 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf report --stdio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># captured on: Tue Jan 28 10:53:38 2014</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># hostname : ubuntu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># os release : 3.5.0-23-generic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf version : 3.5.7.2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># arch : x86_64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus online : 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus avail : 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpudesc : Intel(R) Core(TM) i7-3820QM CPU @ 2.70GHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpuid : GenuineIntel,6,58,9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># total memory : 1011932 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cmdline : /usr/bin/perf_3.5.0-23 record -e syscalls:sys_enter_connect -a </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = syscalls:sys_enter_connect, type = 2, config = 0x38b, ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_CPU_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_NUMA_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Samples: 21  of event &#x27;syscalls:sys_enter_connect&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Event count (approx.): 21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Overhead  Command       Shared Object                       Symbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ........  .......  ..................  ...........................</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    52.38%     sshd  libc-2.15.so        [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    19.05%   groups  libc-2.15.so        [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     9.52%     sshd  libpthread-2.15.so  [.] __connect_internal     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     9.52%     mesg  libc-2.15.so        [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     9.52%     bash  libc-2.15.so        [.] __GI___connect_internal</span><br></span></code></pre></div></div>
<p>The report shows that sshd, groups, mesg, and bash are all performing connect() syscalls. Ring a bell?</p>
<p>The stack traces that led to the connect() can explain why:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e syscalls:sys_enter_connect -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.057 MB perf.data (~2499 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf report --stdio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    55.00%     sshd  libc-2.15.so        [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--27.27%-- add_one_listen_addr.isra.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--27.27%-- __nscd_get_mapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          __nscd_get_map_ref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--27.27%-- __nscd_open_socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   --18.18%-- [...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    20.00%   groups  libc-2.15.so        [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             --- __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                |--50.00%-- __nscd_get_mapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                |          __nscd_get_map_ref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 --50.00%-- __nscd_open_socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    10.00%     mesg  libc-2.15.so        [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--50.00%-- __nscd_get_mapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          __nscd_get_map_ref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   --50.00%-- __nscd_open_socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    10.00%     bash  libc-2.15.so        [.] __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- __GI___connect_internal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--50.00%-- __nscd_get_mapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          __nscd_get_map_ref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   --50.00%-- __nscd_open_socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     5.00%     sshd  libpthread-2.15.so  [.] __connect_internal     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- __connect_internal</span><br></span></code></pre></div></div>
<p>Ah, these are nscd calls: the name service cache daemon. If you see hexadecimal numbers and not function names, you will need to install debug info: see the earlier section on <a href="https://www.brendangregg.com/#Symbols" target="_blank" rel="noopener noreferrer">Symbols</a>. These nscd calls are likely triggered by calling getaddrinfo(), which server software may be using to resolve IP addresses for logging, or for matching hostnames in config files. Browsing the stack traces should identify why.</p>
<p>For sshd, this was called via add_one_listen_addr(): a name that was only visible after adding the openssh-server-dbgsym package. Unfortunately, the stack trace doesn&#x27;t continue after add_one_listen_add(). I can browse the OpenSSH code to figure out the reasons we&#x27;re calling into add_one_listen_add(), or, I can get the stack traces to work. See the earlier section on <a href="https://www.brendangregg.com/#StackTraces" target="_blank" rel="noopener noreferrer">Stack Traces</a>.</p>
<p>I took a quick look at the OpenSSH code, and it looks like this code-path is due to parsing ListenAddress from the sshd_config file, which can contain either an IP address or a hostname.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="socket-buffers">Socket Buffers<a href="#socket-buffers" class="hash-link" aria-label="Socket Buffers的直接链接" title="Socket Buffers的直接链接" translate="no">​</a></h3>
<p>Tracing the consumption of socket buffers, and the stack traces, is one way to identify what is leading to socket or network I/O.</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e &#x27;skb:consume_skb&#x27; -ag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.065 MB perf.data (~2851 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf report</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    74.42%  swapper  [kernel.kallsyms]  [k] consume_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            --- consume_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                arp_process</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                arp_rcv</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                __netif_receive_skb_core</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                __netif_receive_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                netif_receive_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                virtnet_poll</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                net_rx_action</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                __do_softirq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                irq_exit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                do_IRQ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret_from_intr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                default_idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cpu_idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                start_secondary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    25.58%     sshd  [kernel.kallsyms]  [k] consume_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- consume_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   dev_kfree_skb_any</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   free_old_xmit_skbs.isra.24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   start_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   dev_hard_start_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   sch_direct_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   dev_queue_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ip_finish_output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ip_output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ip_local_out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ip_queue_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   tcp_transmit_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   tcp_write_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   __tcp_push_pending_frames</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   inet_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   sock_aio_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   do_sync_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   vfs_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   sys_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   system_call_fastpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   __write_nocancel</span><br></span></code></pre></div></div>
<p>The swapper stack shows the network receive path, triggered by an interrupt. The sshd path shows writes.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="65-static-user-tracing">6.5. Static User Tracing<a href="#65-static-user-tracing" class="hash-link" aria-label="6.5. Static User Tracing的直接链接" title="6.5. Static User Tracing的直接链接" translate="no">​</a></h2>
<p>Support was added in later 4.x series kernels. The following demonstrates Linux 4.10 (with an additional patchset), and tracing the Node.js USDT probes:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf buildid-cache --add \`which node\`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf list | grep sdt_node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sdt_node:gc__done                                  [SDT event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sdt_node:gc__start                                 [SDT event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sdt_node:http__client__request                     [SDT event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sdt_node:http__client__response                    [SDT event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sdt_node:http__server__request                     [SDT event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sdt_node:http__server__response                    [SDT event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sdt_node:net__server__connection                   [SDT event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sdt_node:net__stream__end                          [SDT event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e sdt_node:http__server__request -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.446 MB perf.data (3 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node  7646 [002]   361.012364: sdt_node:http__server__request: (dc2e69)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node  7646 [002]   361.204718: sdt_node:http__server__request: (dc2e69)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node  7646 [002]   361.363043: sdt_node:http__server__request: (dc2e69)</span><br></span></code></pre></div></div>
<p>XXX fill me in, including how to use arguments.</p>
<p>If you are on an older kernel, say, Linux 4.4-4.9, you can probably get these to work with adjustments (I&#x27;ve even hacked them up with <a href="http://www.brendangregg.com/blog/2015-07-03/hacking-linux-usdt-ftrace.html" target="_blank" rel="noopener noreferrer">ftrace</a> for older kernels), but since they have been in development, I haven&#x27;t seen documentation outside of lkml, so you&#x27;ll need to figure it out. (On this kernel range, you might find more documentation for tracing these with <a href="https://www.brendangregg.com/ebpf.html#bcc" target="_blank" rel="noopener noreferrer">bcc/eBPF</a>, including using the trace.py tool.)</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="66-dynamic-tracing">6.6. Dynamic Tracing<a href="#66-dynamic-tracing" class="hash-link" aria-label="6.6. Dynamic Tracing的直接链接" title="6.6. Dynamic Tracing的直接链接" translate="no">​</a></h2>
<p>For kernel analysis, I&#x27;m using CONFIG_KPROBES=y and CONFIG_KPROBE_EVENTS=y, to enable kernel dynamic tracing, and CONFIG_FRAME_POINTER=y, for frame pointer-based kernel stacks. For user-level analysis, CONFIG_UPROBES=y and CONFIG_UPROBE_EVENTS=y, for user-level dynamic tracing.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kernel-tcp_sendmsg">Kernel: tcp_sendmsg()<a href="#kernel-tcp_sendmsg" class="hash-link" aria-label="Kernel: tcp_sendmsg()的直接链接" title="Kernel: tcp_sendmsg()的直接链接" translate="no">​</a></h3>
<p>This example shows instrumenting the kernel tcp_sendmsg() function on the Linux 3.9.3 kernel:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe --add tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Failed to find path of kernel module.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Added new event:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  probe:tcp_sendmsg    (on tcp_sendmsg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">You can now use it in all perf tools, such as:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf record -e probe:tcp_sendmsg -aR sleep 1</span><br></span></code></pre></div></div>
<p>This adds a new tracepoint event. It suggests using the -R option, to collect raw sample records, which is already the default for tracepoints. Tracing this event for 5 seconds, recording stack traces:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e probe:tcp_sendmsg -a -g -- sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.228 MB perf.data (~9974 samples) ]</span><br></span></code></pre></div></div>
<p>And the report:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf report --stdio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># captured on: Fri Jan 31 20:10:14 2014</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># hostname : pgbackup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># os release : 3.9.3-ubuntu-12-opt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf version : 3.9.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># arch : x86_64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus online : 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus avail : 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpudesc : Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpuid : GenuineIntel,6,45,7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># total memory : 8179104 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cmdline : /lib/modules/3.9.3/build/tools/perf/perf record -e probe:tcp_sendmsg -a -g -- sleep 5 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = probe:tcp_sendmsg, type = 2, config = 0x3b2, config1 = 0x0, config2 = 0x0, ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_CPU_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_NUMA_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># pmu mappings: software = 1, tracepoint = 2, breakpoint = 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Samples: 12  of event &#x27;probe:tcp_sendmsg&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Event count (approx.): 12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Overhead  Command      Shared Object           Symbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ........  .......  .................  ...............</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   100.00%     sshd  [kernel.kallsyms]  [k] tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               --- tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   sock_aio_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   do_sync_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   vfs_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   sys_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   system_call_fastpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   __write_nocancel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |--8.33%-- 0x50f00000001b810</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   --91.67%-- [...]</span><br></span></code></pre></div></div>
<p>This shows the path from the write() system call to tcp_sendmsg().</p>
<p>You can delete these dynamic tracepoints if you want after use, using perf probe --del.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kernel-tcp_sendmsg-with-size">Kernel: tcp_sendmsg() with size<a href="#kernel-tcp_sendmsg-with-size" class="hash-link" aria-label="Kernel: tcp_sendmsg() with size的直接链接" title="Kernel: tcp_sendmsg() with size的直接链接" translate="no">​</a></h3>
<p>If your kernel has debuginfo (CONFIG_DEBUG_INFO=y), you can fish out kernel variables from functions. This is a simple example of examining a size_t (integer), on Linux 3.13.1.</p>
<p>Listing variables available for tcp_sendmsg():</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe -V tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Available variables at tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @&lt;tcp_sendmsg+0&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size_t  size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct kiocb*   iocb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct msghdr*  msg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct sock*    sk</span><br></span></code></pre></div></div>
<p>Creating a probe for tcp_sendmsg() with the &quot;size&quot; variable:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe --add &#x27;tcp_sendmsg size&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Added new event:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  probe:tcp_sendmsg    (on tcp_sendmsg with size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">You can now use it in all perf tools, such as:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf record -e probe:tcp_sendmsg -aR sleep 1</span><br></span></code></pre></div></div>
<p>Tracing this probe:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e probe:tcp_sendmsg -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.052 MB perf.data (~2252 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># captured on: Fri Jan 31 23:49:55 2014</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># hostname : dev1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># os release : 3.13.1-ubuntu-12-opt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf version : 3.13.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># arch : x86_64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus online : 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus avail : 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpudesc : Intel(R) Xeon(R) CPU E5645 @ 2.40GHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpuid : GenuineIntel,6,44,2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># total memory : 1796024 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cmdline : /usr/bin/perf record -e probe:tcp_sendmsg -a </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = probe:tcp_sendmsg, type = 2, config = 0x1dd, config1 = 0x0, config2 = ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_CPU_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_NUMA_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># pmu mappings: software = 1, tracepoint = 2, breakpoint = 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  1301 [001]   502.424719: probe:tcp_sendmsg: (ffffffff81505d80) size=b0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  1301 [001]   502.424814: probe:tcp_sendmsg: (ffffffff81505d80) size=40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2371 [000]   502.952590: probe:tcp_sendmsg: (ffffffff81505d80) size=27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2372 [000]   503.025023: probe:tcp_sendmsg: (ffffffff81505d80) size=3c0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2372 [001]   503.203776: probe:tcp_sendmsg: (ffffffff81505d80) size=98</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2372 [001]   503.281312: probe:tcp_sendmsg: (ffffffff81505d80) size=2d0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2372 [001]   503.461358: probe:tcp_sendmsg: (ffffffff81505d80) size=30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2372 [001]   503.670239: probe:tcp_sendmsg: (ffffffff81505d80) size=40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2372 [001]   503.742565: probe:tcp_sendmsg: (ffffffff81505d80) size=140</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2372 [001]   503.822005: probe:tcp_sendmsg: (ffffffff81505d80) size=20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2371 [000]   504.118728: probe:tcp_sendmsg: (ffffffff81505d80) size=30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  2371 [000]   504.192575: probe:tcp_sendmsg: (ffffffff81505d80) size=70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>The size is shown as hexadecimal.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kernel-tcp_sendmsg-line-number-and-local-variable">Kernel: tcp_sendmsg() line number and local variable<a href="#kernel-tcp_sendmsg-line-number-and-local-variable" class="hash-link" aria-label="Kernel: tcp_sendmsg() line number and local variable的直接链接" title="Kernel: tcp_sendmsg() line number and local variable的直接链接" translate="no">​</a></h3>
<p>With debuginfo, perf_events can create tracepoints for lines within kernel functions. Listing available line probes for tcp_sendmsg():</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe -L tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;tcp_sendmsg@/mnt/src/linux-3.14.5/net/ipv4/tcp.c:0&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      0  int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        size_t size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      2  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct iovec *iov;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct tcp_sock *tp = tcp_sk(sk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct sk_buff *skb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      6         int iovlen, flags, err, copied = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      7         int mss_now = 0, size_goal, copied_syn = 0, offset = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bool sg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                long timeo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     79                 while (seglen &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                int copy = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     81                         int max = size_goal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                skb = tcp_write_queue_tail(sk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     84                         if (tcp_send_head(sk)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     85                                 if (skb-&gt;ip_summed == CHECKSUM_NONE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                max = mss_now;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     87                                 copy = max - skb-&gt;len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     90                         if (copy &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         new_segment:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>This is Linux 3.14.5; your kernel version may look different. Lets check what variables are available on line 81:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe -V tcp_sendmsg:81</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Available variables at tcp_sendmsg:81</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @&lt;tcp_sendmsg+537&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bool    sg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int     copied</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int     copied_syn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int     flags</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int     mss_now</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int     offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int     size_goal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                long int        timeo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size_t  seglen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct iovec*   iov</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct sock*    sk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                unsigned char*  from</span><br></span></code></pre></div></div>
<p>Now lets trace line 81, with the seglen variable that is checked in the loop:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe --add &#x27;tcp_sendmsg:81 seglen&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Added new event:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  probe:tcp_sendmsg    (on tcp_sendmsg:81 with seglen)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">You can now use it in all perf tools, such as:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf record -e probe:tcp_sendmsg -aR sleep 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e probe:tcp_sendmsg -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.188 MB perf.data (~8200 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sshd  4652 [001] 2082360.931086: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   app_plugin.pl  2400 [001] 2082360.970489: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        postgres  2422 [000] 2082360.970703: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   app_plugin.pl  2400 [000] 2082360.970890: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x7b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        postgres  2422 [001] 2082360.971099: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0xb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   app_plugin.pl  2400 [000] 2082360.971140: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>This is pretty amazing. Remember that you can also include in-kernel filtering using --filter, to match only the data you want.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="user-malloc">User: malloc()<a href="#user-malloc" class="hash-link" aria-label="User: malloc()的直接链接" title="User: malloc()的直接链接" translate="no">​</a></h3>
<p>While this is an interesting example, I want to say right off the bat that malloc() calls are very frequent, so you will need to consider the overheads of tracing calls like this.</p>
<p>Adding a libc malloc() probe:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe -x /lib/x86_64-linux-gnu/libc-2.15.so --add malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Added new event:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  probe_libc:malloc    (on 0x82f20)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">You can now use it in all perf tools, such as:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf record -e probe_libc:malloc -aR sleep 1</span><br></span></code></pre></div></div>
<p>Tracing it system-wide:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e probe_libc:malloc -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C[ perf record: Woken up 12 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 3.522 MB perf.data (~153866 samples) ]</span><br></span></code></pre></div></div>
<p>The report:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf report -n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Samples: 45K of event &#x27;probe_libc:malloc&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Event count (approx.): 45158</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Overhead       Samples          Command  Shared Object      Symbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ........  ............  ...............  .............  ..........</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    42.72%         19292       apt-config  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    19.71%          8902             grep  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     7.88%          3557             sshd  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     6.25%          2824              sed  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     6.06%          2738            which  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     4.12%          1862  update-motd-upd  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     3.72%          1680             stat  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1.68%           758            login  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1.21%           546        run-parts  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1.21%           545               ls  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.80%           360        dircolors  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.56%           252               tr  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.54%           242              top  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.49%           222       irqbalance  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.44%           200             dpkg  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.38%           173         lesspipe  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.29%           130  update-motd-fsc  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.25%           112            uname  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.24%           108              cut  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.23%           104           groups  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.21%            94  release-upgrade  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.18%            82        00-header  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.14%            62             mesg  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.09%            42  update-motd-reb  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.09%            40             date  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.08%            35             bash  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.08%            35         basename  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.08%            34          dirname  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.06%            29               sh  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.06%            26        99-footer  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.05%            24              cat  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.04%            18             expr  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.04%            17         rsyslogd  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.03%            12             stty  libc-2.15.so   [.] malloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.00%             1             cron  libc-2.15.so   [.] malloc</span><br></span></code></pre></div></div>
<p>This shows the most malloc() calls were by apt-config, while I was tracing.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="user-malloc-with-size">User: malloc() with size<a href="#user-malloc-with-size" class="hash-link" aria-label="User: malloc() with size的直接链接" title="User: malloc() with size的直接链接" translate="no">​</a></h3>
<p>As of the Linux 3.13.1 kernel, this is not supported yet:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe -x /lib/x86_64-linux-gnu/libc-2.15.so --add &#x27;malloc size&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Debuginfo-analysis is not yet supported with -x/--exec option.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Error: Failed to add events. (-38)</span><br></span></code></pre></div></div>
<p>As a workaround, you can access the registers (on Linux 3.7+). For example, on x86_64:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf probe -x /lib64/libc-2.17.so &#x27;--add=malloc size=%di&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       probe_libc:malloc    (on 0x800c0 with size=%di)</span><br></span></code></pre></div></div>
<p>These registers (&quot;%di&quot; etc) are dependent on your processor architecture. To figure out which ones to use, see the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI" target="_blank" rel="noopener noreferrer">X86 calling conventions</a> on Wikipedia, or page 24 of the <a href="http://x86-64.org/documentation/abi.pdf" target="_blank" rel="noopener noreferrer">AMD64 ABI</a> (PDF). (Thanks Jose E. Nunez for digging out these references.)</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="67-scheduler-analysis">6.7. Scheduler Analysis<a href="#67-scheduler-analysis" class="hash-link" aria-label="6.7. Scheduler Analysis的直接链接" title="6.7. Scheduler Analysis的直接链接" translate="no">​</a></h2>
<p>The perf sched subcommand provides a number of tools for analyzing kernel CPU scheduler behavior. You can use this to identify and quantify issues of scheduler latency.</p>
<p>The current overhead of this tool (as of up to Linux 4.10) may be noticeable, as it instruments and dumps scheduler events to the perf.data file for later analysis. For example:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched record -- sleep 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 1.886 MB perf.data (13502 samples) ]</span><br></span></code></pre></div></div>
<p>That&#x27;s 1.9 Mbytes for one second, including 13,502 samples. The size and rate will be relative to your workload and number of CPUs (this example is an 8 CPU server running a software build). How this is written to the file system has been optimized: it only woke up one time to read the event buffers and write them to disk, which greatly reduces overhead. That said, there are still significant overheads with instrumenting all scheduler events and writing event data to the file system. These events:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf script --header</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># captured on: Sun Feb 26 19:40:00 2017</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># hostname : bgregg-xenial</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># os release : 4.10-virtual</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf version : 4.10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># arch : x86_64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus online : 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus avail : 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpudesc : Intel(R) Xeon(R) CPU E5-2680 v2 @ 2.80GHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpuid : GenuineIntel,6,62,4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># total memory : 15401700 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cmdline : /usr/bin/perf sched record -- sleep 1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_switch, , id = { 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759 }, type = 2, size = 11...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_stat_wait, , id = { 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767 }, type = 2, size =...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_stat_sleep, , id = { 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775 }, type = 2, size ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_stat_iowait, , id = { 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783 }, type = 2, size...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_stat_runtime, , id = { 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791 }, type = 2, siz...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_process_fork, , id = { 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799 }, type = 2, siz...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_wakeup, , id = { 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807 }, type = 2, size = 11...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_wakeup_new, , id = { 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815 }, type = 2, size ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_migrate_task, , id = { 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823 }, type = 2, siz...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_CPU_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_NUMA_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># pmu mappings: breakpoint = 5, power = 7, software = 1, tracepoint = 2, msr = 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_CACHE info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># missing features: HEADER_BRANCH_STACK HEADER_GROUP_DESC HEADER_AUXTRACE HEADER_STAT </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf 16984 [005] 991962.879966:       sched:sched_wakeup: comm=perf pid=16999 prio=120 target_cpu=005</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>If overhead is a problem, you can use my <a href="https://www.brendangregg.com/ebpf.html#bcc" target="_blank" rel="noopener noreferrer">eBPF/bcc Tools</a> including runqlat and runqlen which use in-kernel summaries of scheduler events, reducing overhead further. An advantage of perf sched dumping all events is that you aren&#x27;t limited to the summary. If you caught an intermittent event, you can analyze those recorded events in custom ways until you understood the issue, rather than needing to catch it a second time.</p>
<p>The captured trace file can be reported in a number of ways, summarized by the help message:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched -h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Usage: perf sched [] {record|latency|map|replay|script|timehist}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -D, --dump-raw-trace  dump raw trace in ASCII</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -f, --force           don&#x27;t complain, do it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -i, --input     input file name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -v, --verbose         be more verbose (show symbol address, etc)</span><br></span></code></pre></div></div>
<p><strong>perf sched latency</strong> will summarize scheduler latencies by task, including average and maximum delay:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched latency</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> -----------------------------------------------------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Task                  |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | Maximum delay at       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> -----------------------------------------------------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cat:(6)               |     12.002 ms |        6 | avg:   17.541 ms | max:   29.702 ms | max at: 991962.948070 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ar:17043              |      3.191 ms |        1 | avg:   13.638 ms | max:   13.638 ms | max at: 991963.048070 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  rm:(10)               |     20.955 ms |       10 | avg:   11.212 ms | max:   19.598 ms | max at: 991963.404069 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  objdump:(6)           |     35.870 ms |        8 | avg:   10.969 ms | max:   16.509 ms | max at: 991963.424443 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  :17008:17008          |    462.213 ms |       50 | avg:   10.464 ms | max:   35.999 ms | max at: 991963.120069 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  grep:(7)              |     21.655 ms |       11 | avg:    9.465 ms | max:   24.502 ms | max at: 991963.464082 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fixdep:(6)            |     81.066 ms |        8 | avg:    9.023 ms | max:   19.521 ms | max at: 991963.120068 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mv:(10)               |     30.249 ms |       14 | avg:    8.380 ms | max:   21.688 ms | max at: 991963.200073 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ld:(3)                |     14.353 ms |        6 | avg:    7.376 ms | max:   15.498 ms | max at: 991963.452070 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  recordmcount:(7)      |     14.629 ms |        9 | avg:    7.155 ms | max:   18.964 ms | max at: 991963.292100 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  svstat:17067          |      1.862 ms |        1 | avg:    6.142 ms | max:    6.142 ms | max at: 991963.280069 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cc1:(21)              |   6013.457 ms |     1138 | avg:    5.305 ms | max:   44.001 ms | max at: 991963.436070 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  gcc:(18)              |     43.596 ms |       40 | avg:    3.905 ms | max:   26.994 ms | max at: 991963.380069 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ps:17073              |     27.158 ms |        4 | avg:    3.751 ms | max:    8.000 ms | max at: 991963.332070 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>To shed some light as to how this is instrumented and calculated, I&#x27;ll show the events that led to the top event&#x27;s &quot;Maximum delay at&quot; of 29.702 ms. Here are the raw events from perf sched script:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sh 17028 [001] 991962.918368:   sched:sched_wakeup_new: comm=sh pid=17030 prio=120 target_cpu=002</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     cc1 16819 [002] 991962.948070:       sched:sched_switch: prev_comm=cc1 prev_pid=16819 prev_prio=120</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                            prev_state=R ==&gt; next_comm=sh next_pid=17030 next_prio=120</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>The time from the wakeup (991962.918368, which is in seconds) to the context switch (991962.948070) is 29.702 ms. This process is listed as &quot;sh&quot; (shell) in the raw events, but execs &quot;cat&quot; soon after, so is shown as &quot;cat&quot; in the perf sched latency output.</p>
<p><strong>perf sched map</strong> shows all CPUs and context-switch events, with columns representing what each CPU was doing and when. It&#x27;s the kind of data you see visualized in scheduler analysis GUIs (including perf timechart, with the layout rotated 90 degrees). Example output:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      *A0           991962.879971 secs A0 =&gt; perf:16999</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       A0     *B0   991962.880070 secs B0 =&gt; cc1:16863</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          *C0          A0      B0   991962.880070 secs C0 =&gt; :17023:17023</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  *D0      C0          A0      B0   991962.880078 secs D0 =&gt; ksoftirqd/0:6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   D0      C0 *E0      A0      B0   991962.880081 secs E0 =&gt; ksoftirqd/3:28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   D0      C0 *F0      A0      B0   991962.880093 secs F0 =&gt; :17022:17022</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  *G0      C0  F0      A0      B0   991962.880108 secs G0 =&gt; :17016:17016</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0      C0  F0     *H0      B0   991962.880256 secs H0 =&gt; migration/5:39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0      C0  F0     *I0      B0   991962.880276 secs I0 =&gt; perf:16984</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0      C0  F0     *J0      B0   991962.880687 secs J0 =&gt; cc1:16996</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0      C0 *K0      J0      B0   991962.881839 secs K0 =&gt; cc1:16945</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0      C0  K0      J0 *L0  B0   991962.881841 secs L0 =&gt; :17020:17020</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0      C0  K0      J0 *M0  B0   991962.882289 secs M0 =&gt; make:16637</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0      C0  K0      J0 *N0  B0   991962.883102 secs N0 =&gt; make:16545</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0     *O0  K0      J0  N0  B0   991962.883880 secs O0 =&gt; cc1:16819</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0 *A0  O0  K0      J0  N0  B0   991962.884069 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0  A0  O0  K0 *P0  J0  N0  B0   991962.884076 secs P0 =&gt; rcu_sched:7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0  A0  O0  K0 *Q0  J0  N0  B0   991962.884084 secs Q0 =&gt; cc1:16831</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0  A0  O0  K0  Q0  J0 *R0  B0   991962.884843 secs R0 =&gt; cc1:16825</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0 *S0  O0  K0  Q0  J0  R0  B0   991962.885636 secs S0 =&gt; cc1:16900</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0  S0  O0 *T0  Q0  J0  R0  B0   991962.886893 secs T0 =&gt; :17014:17014</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   G0  S0  O0 *K0  Q0  J0  R0  B0   991962.886917 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>This is an 8 CPU system, and you can see the 8 columns for each CPU starting from the left. Some CPU columns begin blank, as we&#x27;ve yet to trace an event on that CPU at the start of the profile. They quickly become populated.</p>
<p>The two character codes you see (&quot;A0&quot;, &quot;C0&quot;) are identifiers for tasks, which are mapped on the right (&quot;=&gt;&quot;). This is more compact than using process (task) IDs. The &quot;*&quot; shows which CPU had the context switch event, and the new event that was running. For example, the very last line shows that at 991962.886917 (seconds) CPU 4 context-switched to K0 (a &quot;cc1&quot; process, PID 16945).</p>
<p>That example was from a busy system. Here&#x27;s an idle system:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      *A0           993552.887633 secs A0 =&gt; perf:26596</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  *.                   A0           993552.887781 secs .  =&gt; swapper:0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .                  *B0           993552.887843 secs B0 =&gt; migration/5:39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .                  *.            993552.887858 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .                   .  *A0       993552.887861 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .                  *C0  A0       993552.887903 secs C0 =&gt; bash:26622</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .                  *.   A0       993552.888020 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .          *D0      .   A0       993552.888074 secs D0 =&gt; rcu_sched:7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .          *.       .   A0       993552.888082 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .           .      *C0  A0       993552.888143 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .      *.   .       C0  A0       993552.888173 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .       .   .      *B0  A0       993552.888439 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .       .   .      *.   A0       993552.888454 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .      *C0  .       .   A0       993552.888457 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .       C0  .       .  *.        993552.889257 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .      *.   .       .   .        993552.889764 secs </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .       .  *E0      .   .        993552.889767 secs E0 =&gt; bash:7902</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>Idle CPUs are shown as &quot;.&quot;.</p>
<p>Remember to examine the timestamp column to make sense of this visualization (GUIs use that as a dimension, which is easier to comprehend, but here the numbers are just listed). It&#x27;s also only showing context switch events, and not scheduler latency. The newer timehist command has a visualization (-V) that can include wakeup events.</p>
<p><strong>perf sched timehist</strong> was added in Linux 4.10, and shows the scheduler latency by event, including the time the task was waiting to be woken up (wait time) and the scheduler latency after wakeup to running (sch delay). It&#x27;s the scheduler latency that we&#x27;re more interested in tuning. Example output:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched timehist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Samples do not have callchains.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           time    cpu  task name                       wait time  sch delay   run time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        [tid/pid]                          (msec)     (msec)     (msec)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------- ------  ------------------------------  ---------  ---------  ---------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.879971 [0005]  perf[16984]                         0.000      0.000      0.000 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880070 [0007]  :17008[17008]                       0.000      0.000      0.000 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880070 [0002]  cc1[16880]                          0.000      0.000      0.000 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880078 [0000]  cc1[16881]                          0.000      0.000      0.000 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880081 [0003]  cc1[16945]                          0.000      0.000      0.000 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880093 [0003]  ksoftirqd/3[28]                     0.000      0.007      0.012 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880108 [0000]  ksoftirqd/0[6]                      0.000      0.007      0.030 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880256 [0005]  perf[16999]                         0.000      0.005      0.285 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880276 [0005]  migration/5[39]                     0.000      0.007      0.019 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880687 [0005]  perf[16984]                         0.304      0.000      0.411 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.881839 [0003]  cat[17022]                          0.000      0.000      1.746 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.881841 [0006]  cc1[16825]                          0.000      0.000      0.000 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.885740 [0001]  :17008[17008]                      25.613      0.000      0.057 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.886009 [0001]  sleep[16999]                     1000.104      0.006      0.269 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.886018 [0005]  cc1[17083]                         19.998      0.000      9.948</span><br></span></code></pre></div></div>
<p>This output includes the sleep command run to set the duration of perf itself to one second. Note that sleep &#x27;s wait time is 1000.104 milliseconds because I had run &quot;sleep 1&quot;: that&#x27;s the time it was asleep waiting its timer wakeup event. Its scheduler latency was only 0.006 milliseconds, and its time on-CPU was 0.269 milliseconds.</p>
<p>There are a number of options to timehist, including -V to add a CPU visualization column, -M to add migration events, and -w for wakeup events. For example:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched timehist -MVw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Samples do not have callchains.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           time    cpu  012345678  task name           wait time  sch delay   run time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   [tid/pid]              (msec)     (msec)     (msec)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------- ------  ---------  ------------------  ---------  ---------  ---------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.879966 [0005]             perf[16984]                                          awakened: perf[16999]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.879971 [0005]       s     perf[16984]             0.000      0.000      0.000                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880070 [0007]         s   :17008[17008]           0.000      0.000      0.000                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880070 [0002]    s        cc1[16880]              0.000      0.000      0.000                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880071 [0000]             cc1[16881]                                           awakened: ksoftirqd/0[6]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880073 [0003]             cc1[16945]                                           awakened: ksoftirqd/3[28]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880078 [0000]  s          cc1[16881]              0.000      0.000      0.000                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880081 [0003]     s       cc1[16945]              0.000      0.000      0.000                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880093 [0003]     s       ksoftirqd/3[28]         0.000      0.007      0.012                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880108 [0000]  s          ksoftirqd/0[6]          0.000      0.007      0.030                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880249 [0005]             perf[16999]                                          awakened: migration/5[39]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880256 [0005]       s     perf[16999]             0.000      0.005      0.285                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880264 [0005]        m      migration/5[39]                                      migrated: perf[16999] cpu 5 =&gt; 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880276 [0005]       s     migration/5[39]         0.000      0.007      0.019                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880682 [0005]        m      perf[16984]                                          migrated: cc1[16996] cpu 0 =&gt; 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.880687 [0005]       s     perf[16984]             0.304      0.000      0.411                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991962.881834 [0003]             cat[17022]                                           awakened: :17020</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.885734 [0001]             :17008[17008]                                        awakened: sleep[16999]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.885740 [0001]   s         :17008[17008]          25.613      0.000      0.057                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.886005 [0001]             sleep[16999]                                         awakened: perf[16984]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.886009 [0001]   s         sleep[16999]         1000.104      0.006      0.269</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.886018 [0005]       s     cc1[17083]             19.998      0.000      9.948</span><br></span></code></pre></div></div>
<p>The CPU visualization column (&quot;012345678&quot;) has &quot;s&quot; for context-switch events, and &quot;m&quot; for migration events, showing the CPU of the event. If you run perf sched record -g, then the stack traces are appended on the right in a single line (not shown here).</p>
<p>The last events in that output include those related to the &quot;sleep 1&quot; command used to time perf. The wakeup happened at 991963.885734, and at 991963.885740 (6 microseconds later) CPU 1 begins to context-switch to the sleep process. The column for that event still shows &quot;:17008[17008]&quot; for what was on-CPU, but the target of the context switch (sleep) is not shown. It is in the raw events:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">:17008 17008 [001] 991963.885740:       sched:sched_switch: prev_comm=cc1 prev_pid=17008 prev_prio=120</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                             prev_state=R ==&gt; next_comm=sleep next_pid=16999 next_prio=120</span><br></span></code></pre></div></div>
<p>The 991963.886005 event shows that the perf command received a wakeup while sleep was running (almost certainly sleep waking up its parent process because it terminated), and then we have the context switch on 991963.886009 where sleep stops running, and a summary is printed out: 1000.104 ms waiting (the &quot;sleep 1&quot;), with 0.006 ms scheduler latency, and 0.269 ms of CPU runtime.</p>
<p>Here I&#x27;ve decorated the timehist output with the details of the context switch destination in red:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">991963.885734 [0001]             :17008[17008]                                        awakened: sleep[16999]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.885740 [0001]   s         :17008[17008]          25.613      0.000      0.057  next: sleep[16999]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.886005 [0001]             sleep[16999]                                         awakened: perf[16984]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.886009 [0001]   s         sleep[16999]         1000.104      0.006      0.269  next: cc1[17008]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  991963.886018 [0005]       s     cc1[17083]             19.998      0.000      9.948  next: perf[16984]</span><br></span></code></pre></div></div>
<p>When sleep finished, a waiting &quot;cc1&quot; process then executed. perf ran on the following context switch, and is the last event in the profile (perf terminated). I&#x27;ve added this as a -n/--next option to perf (should arrive in Linux 4.11 or 4.12).</p>
<p><strong>perf sched script</strong> dumps all events (similar to perf script):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf 16984 [005] 991962.879960: sched:sched_stat_runtime: comm=perf pid=16984 runtime=3901506 [ns] vruntime=165...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf 16984 [005] 991962.879966:       sched:sched_wakeup: comm=perf pid=16999 prio=120 target_cpu=005</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf 16984 [005] 991962.879971:       sched:sched_switch: prev_comm=perf prev_pid=16984 prev_prio=120 prev_stat...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    perf 16999 [005] 991962.880058: sched:sched_stat_runtime: comm=perf pid=16999 runtime=98309 [ns] vruntime=16405...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     cc1 16881 [000] 991962.880058: sched:sched_stat_runtime: comm=cc1 pid=16881 runtime=3999231 [ns] vruntime=7897...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  :17024 17024 [004] 991962.880058: sched:sched_stat_runtime: comm=cc1 pid=17024 runtime=3866637 [ns] vruntime=7810...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     cc1 16900 [001] 991962.880058: sched:sched_stat_runtime: comm=cc1 pid=16900 runtime=3006028 [ns] vruntime=7772...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     cc1 16825 [006] 991962.880058: sched:sched_stat_runtime: comm=cc1 pid=16825 runtime=3999423 [ns] vruntime=7876...</span><br></span></code></pre></div></div>
<p>Each of these events (&quot;sched<!-- -->:sched<!-- -->_stat_runtime&quot; etc) are tracepoints you can instrument directly using perf record.</p>
<p>As I&#x27;ve shown earlier, this raw output can be useful for digging further than the summary commands.</p>
<p><strong>perf sched replay</strong> will take the recorded scheduler events, and then simulate the workload by spawning threads with similar runtimes and context switches. Useful for testing and developing scheduler changes and configuration. Don&#x27;t put too much faith in this (and other) workload replayers: they can be a useful load generator, but it&#x27;s difficult to simulate the real workload completely. Here I&#x27;m running replay with -r -1, to repeat the workload:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf sched replay -r -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">run measurement overhead: 84 nsecs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sleep measurement overhead: 146710 nsecs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">the run test took 1000005 nsecs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">the sleep test took 1107773 nsecs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nr_run_events:        4175</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nr_sleep_events:      4710</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nr_wakeup_events:     2138</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task      0 (             swapper:         0), nr_events: 13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task      1 (             swapper:         1), nr_events: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task      2 (             swapper:         2), nr_events: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task      3 (            kthreadd:         4), nr_events: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task      4 (            kthreadd:         6), nr_events: 29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task    530 (                  sh:     17145), nr_events: 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task    531 (                  sh:     17146), nr_events: 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task    532 (                  sh:     17147), nr_events: 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task    533 (                make:     17148), nr_events: 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">task    534 (                  sh:     17149), nr_events: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#1  : 965.996, ravg: 966.00, cpu: 798.24 / 798.24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#2  : 902.647, ravg: 966.00, cpu: 1157.53 / 798.24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#3  : 945.482, ravg: 966.00, cpu: 925.25 / 798.24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#4  : 943.541, ravg: 966.00, cpu: 761.72 / 798.24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#5  : 914.643, ravg: 966.00, cpu: 1604.32 / 798.24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="68-ebpf">6.8. eBPF<a href="#68-ebpf" class="hash-link" aria-label="6.8. eBPF的直接链接" title="6.8. eBPF的直接链接" translate="no">​</a></h2>
<p>As of Linux 4.4, perf has some enhanced BPF support (aka eBPF or just &quot;BPF&quot;), with more in later kernels. BPF makes perf tracing programmatic, and takes perf from being a counting &amp; sampling-with-post-processing tracer, to a fully in-kernel programmable tracer.</p>
<p>eBPF is currently a little restricted and difficult to use from perf. It&#x27;s getting better all the time. A different and currently easier way to access eBPF is via the bcc Python interface, which is described on my <a href="https://www.brendangregg.com/ebpf.html" target="_blank" rel="noopener noreferrer">eBPF Tools</a> page. On this page, I&#x27;ll discuss perf.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="prerequisites">Prerequisites<a href="#prerequisites" class="hash-link" aria-label="Prerequisites的直接链接" title="Prerequisites的直接链接" translate="no">​</a></h3>
<p>Linux 4.4 at least. Newer versions have more perf/BPF features, so the newer the better. Also clang (eg, apt-get install clang).</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kmem_cache_alloc-from-example">kmem_cache_alloc from Example<a href="#kmem_cache_alloc-from-example" class="hash-link" aria-label="kmem_cache_alloc from Example的直接链接" title="kmem_cache_alloc from Example的直接链接" translate="no">​</a></h3>
<p>This program traces the kernel kmem_cache_alloc() function, only if its calling function matches a specified range, filtered in kernel context. You can imagine doing this for efficiency: instead of tracing all allocations, which can be very frequent and add significant overhead, you filter for just a range of kernel calling functions of interest, such as a kernel module. I&#x27;ll loosely match tcp functions as an example, which are in memory at these addresses:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># grep tcp /proc/kallsyms | more</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff817c1bb0 t tcp_get_info_chrono_stats</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff817c1c60 T tcp_init_sock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff817c1e30 t tcp_splice_data_recv</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff817c1e70 t tcp_push</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff817c20a0 t tcp_send_mss</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff817c2170 t tcp_recv_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff817c2250 t tcp_cleanup_rbuf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff818524f0 T tcp6_proc_exit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff81852510 T tcpv6_exit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff818648a0 t tcp6_gro_complete</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff81864910 t tcp6_gro_receive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff81864ae0 t tcp6_gso_segment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffffff8187bd89 t tcp_v4_inbound_md5_hash</span><br></span></code></pre></div></div>
<p>I&#x27;ll assume these functions are contiguous, so that by tracing the range 0xffffffff817c1bb0 to 0xffffffff8187bd89, I&#x27;m matching much of tcp.</p>
<p>Here is my BPF program, kca_from.c:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;uapi/linux/bpf.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;uapi/linux/ptrace.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define SEC(NAME) __attribute__((section(NAME), used))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Edit the following to match the instruction address range you want to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * sample. Eg, look in /proc/kallsyms. The addresses will change for each</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * kernel version and build.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define RANGE_START  0xffffffff817c1bb0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define RANGE_END    0xffffffff8187bd89</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct bpf_map_def {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int key_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int value_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int max_entries;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int (*probe_read)(void *dst, int size, void *src) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (void *)BPF_FUNC_probe_read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int (*get_smp_processor_id)(void) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (void *)BPF_FUNC_get_smp_processor_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int (*perf_event_output)(void *, struct bpf_map_def *, int, void *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long) = (void *)BPF_FUNC_perf_event_output;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct bpf_map_def SEC(&quot;maps&quot;) channel = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .type = BPF_MAP_TYPE_PERF_EVENT_ARRAY,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .key_size = sizeof(int),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .value_size = sizeof(u32),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .max_entries = __NR_CPUS__,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SEC(&quot;func=kmem_cache_alloc&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int func(struct pt_regs *ctx)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u64 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // x86_64 specific:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    probe_read(&amp;ret, sizeof(ret), (void *)(ctx-&gt;bp+8));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret &gt;= RANGE_START &amp;&amp; ret &lt; RANGE_END) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        perf_event_output(ctx, &amp;channel, get_smp_processor_id(), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;ret, sizeof(ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int _version SEC(&quot;version&quot;) = LINUX_VERSION_CODE;</span><br></span></code></pre></div></div>
<p>Now I&#x27;ll execute it, then dump the events:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e bpf-output/no-inherit,name=evt/ -e ./kca_from.c/map:channel.event=evt/ -a -- sleep 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bpf: builtin compilation failed: -95, try external compiler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.214 MB perf.data (3 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> testserver00001 14337 [003] 481432.395181:          0     evt:  ffffffff81210f51 kmem_cache_alloc (/lib/modules/...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      BPF output: 0000: 0f b4 7c 81 ff ff ff ff  ..|.....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  0008: 00 00 00 00              ....    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis-server  1871 [005] 481432.395258:          0     evt:  ffffffff81210f51 kmem_cache_alloc (/lib/modules/...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      BPF output: 0000: 14 55 7c 81 ff ff ff ff  .U|.....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  0008: 00 00 00 00              ....    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis-server  1871 [005] 481432.395456:          0     evt:  ffffffff81210f51 kmem_cache_alloc (/lib/modules/...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      BPF output: 0000: fe dc 7d 81 ff ff ff ff  ..}.....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  0008: 00 00 00 00              ....</span><br></span></code></pre></div></div>
<p>It worked: the &quot;BPF output&quot; records contain addresses in our range: 0xffffffff817cb40f, and so on. kmem_cache_alloc() is a frequently called function, so that it only matched a few entries in one second of tracing is an indication it is working (I can also relax that range to confirm it).</p>
<p>Adding stack traces with -g:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e bpf-output/no-inherit,name=evt/ -e ./kca_from.c/map:channel.event=evt/ -a -g -- sleep 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bpf: builtin compilation failed: -95, try external compiler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Woken up 1 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 0.215 MB perf.data (3 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">testserver00001 16744 [002] 481518.262579:          0                 evt: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  410f51 kmem_cache_alloc (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9cb40f tcp_conn_request (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9da243 tcp_v4_conn_request (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9d0936 tcp_rcv_state_process (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9db102 tcp_v4_do_rcv (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9dcabf tcp_v4_rcv (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b4af4 ip_local_deliver_finish (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b4dff ip_local_deliver (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b477b ip_rcv_finish (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b50fb ip_rcv (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  97119e __netif_receive_skb_core (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  971708 __netif_receive_skb (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9725df process_backlog (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  971c8e net_rx_action (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  a8e58d __do_softirq (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  a8c9ac do_softirq_own_stack (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  28a061 do_softirq.part.18 (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  28a0ed __local_bh_enable_ip (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b8ff3 ip_finish_output2 (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b9f43 ip_finish_output (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9ba9f6 ip_output (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9ba155 ip_local_out (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9ba48a ip_queue_xmit (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9d3823 tcp_transmit_skb (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9d5345 tcp_connect (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9da764 tcp_v4_connect (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9f1abc __inet_stream_connect (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9f1d38 inet_stream_connect (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  952fd9 SYSC_connect (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  953c1e sys_connect (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  a8b9fb entry_SYSCALL_64_fastpath (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   10800 __GI___libc_connect (/lib/x86_64-linux-gnu/libpthread-2.23.so)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      BPF output: 0000: 0f b4 7c 81 ff ff ff ff  ..|.....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  0008: 00 00 00 00              ....    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-server  1871 [003] 481518.262670:          0                 evt: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  410f51 kmem_cache_alloc (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9c5514 tcp_poll (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9515ba sock_poll (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  485699 sys_epoll_ctl (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  a8b9fb entry_SYSCALL_64_fastpath (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  106dca epoll_ctl (/lib/x86_64-linux-gnu/libc-2.23.so)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      BPF output: 0000: 14 55 7c 81 ff ff ff ff  .U|.....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  0008: 00 00 00 00              ....    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-server  1871 [003] 481518.262870:          0                 evt: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  410f51 kmem_cache_alloc (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9ddcfe tcp_time_wait (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9cefff tcp_fin (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9cf630 tcp_data_queue (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9d0abd tcp_rcv_state_process (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9db102 tcp_v4_do_rcv (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9dca8b tcp_v4_rcv (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b4af4 ip_local_deliver_finish (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b4dff ip_local_deliver (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b477b ip_rcv_finish (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b50fb ip_rcv (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  97119e __netif_receive_skb_core (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  971708 __netif_receive_skb (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9725df process_backlog (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  971c8e net_rx_action (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  a8e58d __do_softirq (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  a8c9ac do_softirq_own_stack (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  28a061 do_softirq.part.18 (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  28a0ed __local_bh_enable_ip (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b8ff3 ip_finish_output2 (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9b9f43 ip_finish_output (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9ba9f6 ip_output (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9ba155 ip_local_out (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9ba48a ip_queue_xmit (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9d3823 tcp_transmit_skb (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9d3e24 tcp_write_xmit (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9d4c31 __tcp_push_pending_frames (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9d6881 tcp_send_fin (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9c70b7 tcp_close (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  9f161c inet_release (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  95181f sock_release (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  951892 sock_close (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  43b2f7 __fput (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  43b46e ____fput (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  2a3cfe task_work_run (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  2032ba exit_to_usermode_loop (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  203b29 syscall_return_slowpath (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  a8ba88 entry_SYSCALL_64_fastpath (/lib/modules/4.10.0-rc8-virtual/build/vmlinux)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   105cd __GI___libc_close (/lib/x86_64-linux-gnu/libpthread-2.23.so)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      BPF output: 0000: fe dc 7d 81 ff ff ff ff  ..}.....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  0008: 00 00 00 00              ....</span><br></span></code></pre></div></div>
<p>This confirms the parent functions that were matched by the range.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="more-examples">More Examples<a href="#more-examples" class="hash-link" aria-label="More Examples的直接链接" title="More Examples的直接链接" translate="no">​</a></h3>
<p>XXX fill me in.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-visualizations">7. Visualizations<a href="#7-visualizations" class="hash-link" aria-label="7. Visualizations的直接链接" title="7. Visualizations的直接链接" translate="no">​</a></h2>
<p>perf_events has a builtin visualization: timecharts, as well as text-style visualization via its text user interface (TUI) and tree reports. The following two sections show visualizations of my own: flame graphs and heat maps. The software I&#x27;m using is open source and on github, and produces these from perf_events collected data.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="71-flame-graphs">7.1. Flame Graphs<a href="#71-flame-graphs" class="hash-link" aria-label="7.1. Flame Graphs的直接链接" title="7.1. Flame Graphs的直接链接" translate="no">​</a></h2>
<p><a href="https://www.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener noreferrer">Flame Graphs</a> can be produced from perf_events profiling data using the <a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener noreferrer">FlameGraph tools</a> software. This visualizes the same data you see in perf report, and works with any perf.data file that was captured with stack traces (-g).</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="example">Example<a href="#example" class="hash-link" aria-label="Example的直接链接" title="Example的直接链接" translate="no">​</a></h3>
<p>This example CPU flame graph shows a network workload for the 3.2.9-1 Linux kernel, running as a KVM instance (<a href="https://www.brendangregg.com/FlameGraphs/cpu-linux-tcpsend.svg" target="_blank" rel="noopener noreferrer">SVG</a>, <a href="https://www.brendangregg.com/FlameGraphs/cpu-linux-tcpsend.png" target="_blank" rel="noopener noreferrer">PNG</a>):</p>
<p><img decoding="async" loading="lazy" src="/assets/images/7bbbca3bf3f5526d897ebf7750274b44_MD5-8c0a015d6b64de5c3d51112b7df7d015.png" width="2400" height="1380" class="img_ev3q"></p>
<p>Flame Graphs show the sample population across the x-axis, and stack depth on the y-axis. Each function (stack frame) is drawn as a rectangle, with the width relative to the number of samples. See the <a href="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs" target="_blank" rel="noopener noreferrer">CPU Flame Graphs</a> page for the full description of how these work.</p>
<p>You can use the mouse to explore where kernel CPU time is spent, quickly quantifying code-paths and determining where performance tuning efforts are best spent. This example shows that most time was spent in the vp_notify() code-path, spending 70.52% of all on-CPU samples performing iowrite16(), which is handled by the KVM hypervisor. This information has been extremely useful for directing KVM performance efforts.</p>
<p>A similar network workload on a bare metal Linux system looks quite different, as networking isn&#x27;t processed via the virtio-net driver, for a start.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="generation">Generation<a href="#generation" class="hash-link" aria-label="Generation的直接链接" title="Generation的直接链接" translate="no">​</a></h3>
<p>The example flame graph was generated using perf_events and the <a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener noreferrer">FlameGraph tools</a> (this is the old-fashioned method for Linux 2.6.X onwards; see the later Newer perf section):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># git clone https://github.com/brendangregg/FlameGraph  # or download it from github</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cd FlameGraph</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -F 99 -ag -- sleep 60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script | ./stackcollapse-perf.pl &gt; out.perf-folded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cat out.perf-folded | ./flamegraph.pl &gt; perf-kernel.svg</span><br></span></code></pre></div></div>
<p>The first perf command profiles CPU stacks, as explained earlier. I adjusted the rate to 99 Hertz here; I actually generated the flame graph from a 1000 Hertz profile, but I&#x27;d only use that if you had a reason to go faster, which costs more in overhead. The samples are saved in a perf.data file, which can be viewed using perf report:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf report --stdio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Overhead          Command          Shared Object                               Symbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ........  ...............  .....................  ...................................</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    72.18%            iperf  [kernel.kallsyms]      [k] iowrite16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      --- iowrite16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |--99.53%-- vp_notify</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          virtqueue_kick</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          start_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          dev_hard_start_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          sch_direct_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          dev_queue_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          ip_finish_output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          ip_output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          ip_local_out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          ip_queue_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          tcp_transmit_skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          tcp_write_xmit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |--98.16%-- tcp_push_one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          tcp_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          inet_sendmsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          sock_aio_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          do_sync_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          vfs_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          sys_write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          system_call</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          0x369e40e5cd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |          |          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         |           --1.84%-- __tcp_push_pending_frames</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>This tree follows the flame graph when reading it top-down. When using -g/--call-graph (for &quot;caller&quot;, instead of the &quot;callee&quot; default), it generates a tree that follows the flame graph when read bottom-up. The hottest stack trace in the flame graph (@70.52%) can be seen in this perf call graph as the product of the top three nodes (72.18% x 99.53% x 98.16%).</p>
<p>The perf report tree (and the ncurses navigator) do an excellent job at presenting this information as text. However, with text there are limitations. The output often does not fit in one screen (you could say it doesn&#x27;t need to, if the bulk of the samples are identified on the first page). Also, identifying the hottest code paths requires reading the percentages. With the flame graph, all the data is on screen at once, and the hottest code-paths are immediately obvious as the widest functions.</p>
<p>For generating the flame graph, the perf script command dumps the stack samples, which are then aggregated by stackcollapse-perf.pl and folded into single lines per-stack. That output is then converted by flamegraph.pl into the SVG. I included a gratuitous &quot;cat&quot; command to make it clear that flamegraph.pl can process the output of a pipe, which could include Unix commands to filter or preprocess (grep, sed, awk).</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="piping">Piping<a href="#piping" class="hash-link" aria-label="Piping的直接链接" title="Piping的直接链接" translate="no">​</a></h3>
<p>A flame graph can be generated directly by piping all the steps:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf script | ./stackcollapse-perf.pl | ./flamegraph.pl &gt; perf-kernel.svg</span><br></span></code></pre></div></div>
<p>In practice I don&#x27;t do this, as I often re-run flamegraph.pl multiple times, and this one-liner would execute everything multiple times. The output of perf script can be dozens of Mbytes, taking many seconds to process. By writing stackcollapse-perf.pl to a file, you&#x27;ve cached the slowest step, and can also edit the file (vi) to delete unimportant stacks, such as CPU idle threads.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="filtering">Filtering<a href="#filtering" class="hash-link" aria-label="Filtering的直接链接" title="Filtering的直接链接" translate="no">​</a></h3>
<p>The one-line-per-stack output of stackcollapse-perf.pl is also convenient for grep(1). E.g.:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf script | ./stackcollapse-perf.pl &gt; out.perf-folded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># grep -v cpu_idle out.perf-folded | ./flamegraph.pl &gt; nonidle.svg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># grep ext4 out.perf-folded | ./flamegraph.pl &gt; ext4internals.svg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># egrep &#x27;system_call.*sys_(read|write)&#x27; out.perf-folded | ./flamegraph.pl &gt; rw.svg</span><br></span></code></pre></div></div>
<p>I frequently elide the cpu_idle threads in this way, to focus on the real threads that are consuming CPU resources. If I miss this step, the cpu_idle threads can often dominate the flame graph, squeezing the interesting code paths.</p>
<p>Note that it would be a little more efficient to process the output of perf report instead of perf script; better still, perf report could have a report style (eg, &quot;-g folded&quot;) that output folded stacks directly, obviating the need for stackcollapse-perf.pl. There could even be a perf mode that output the SVG directly (which wouldn&#x27;t be the first one; see perf-timechart), although, that would miss the value of being able to grep the folded stacks (which I use frequently).</p>
<p>There are more examples of perf_events CPU flame graphs on the <a href="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#Examples" target="_blank" rel="noopener noreferrer">CPU flame graph</a> page, including a <a href="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#perf" target="_blank" rel="noopener noreferrer">summary</a> of these instructions. I have also shared an example of using perf for a <a href="https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html#BlockIO" target="_blank" rel="noopener noreferrer">Block Device I/O Flame Graph</a>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="newer-perf">Newer perf<a href="#newer-perf" class="hash-link" aria-label="Newer perf的直接链接" title="Newer perf的直接链接" translate="no">​</a></h3>
<p>perf has added features to aid flame graph generation. XXX</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="72-heat-maps">7.2. Heat Maps<a href="#72-heat-maps" class="hash-link" aria-label="7.2. Heat Maps的直接链接" title="7.2. Heat Maps的直接链接" translate="no">​</a></h2>
<p>Since perf_events can record high resolution timestamps (microseconds) for events, some latency measurements can be derived from trace data.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="example-1">Example<a href="#example-1" class="hash-link" aria-label="Example的直接链接" title="Example的直接链接" translate="no">​</a></h3>
<p>The following heat map visualizes disk I/O latency data collected from perf_events (<a href="https://www.brendangregg.com/perf_events/perf_block_latencyheatmap.svg" target="_blank" rel="noopener noreferrer">SVG</a>, <a href="https://www.brendangregg.com/perf_events/perf_block_latencyheatmap.png" target="_blank" rel="noopener noreferrer">PNG</a>):</p>
<p><img decoding="async" loading="lazy" src="/assets/images/967cbfb18a735e79f85791d8f3594cb2_MD5-5f5194e76daa87465b5473694b02576f.png" width="1944" height="968" class="img_ev3q"></p>
<p>Mouse-over blocks to explore the latency distribution over time. The x-axis is the passage of time, the y-axis latency, and the z-axis (color) is the number of I/O at that time and latency range. The distribution is bimodal, with the dark line at the bottom showing that many disk I/O completed with sub-millisecond latency: cache hits. There is a cloud of disk I/O from about 3 ms to 25 ms, which would be caused by random disk I/O (and queueing). Both these modes averaged to the 9 ms we saw earlier.</p>
<p>The following iostat output was collected at the same time as the heat map data was collected (shows a typical one second summary):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># iostat -x 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Device: rrqm/s wrqm/s    r/s   w/s   rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm  %util</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vda       0.00   0.00   0.00  0.00    0.00  0.00     0.00     0.00  0.00    0.00    0.00  0.00   0.00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vdb       0.00   0.00 334.00  0.00 2672.00  0.00    16.00     2.97  9.01    9.01    0.00  2.99 100.00</span><br></span></code></pre></div></div>
<p>This workload has an average I/O time (await) of 9 milliseconds, which sounds like a fairly random workload on 7200 RPM disks. The problem is that we don&#x27;t know the distribution from the iostat output, or any similar latency average. There could be latency outliers present, which is not visible in the average, and yet are causing problems. The heat map did show I/O up to 50 ms, which you might not have expected from that iostat output. There could also be multiple modes, as we saw in the heat map, which are also not visible in an average.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="gathering">Gathering<a href="#gathering" class="hash-link" aria-label="Gathering的直接链接" title="Gathering的直接链接" translate="no">​</a></h3>
<p>I used perf_events to record the block request (disk I/O) issue and completion static tracepoints:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf record -e block:block_rq_issue -e block:block_rq_complete -a sleep 120</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Woken up 36 times to write data ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ perf record: Captured and wrote 8.885 MB perf.data (~388174 samples) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     randread.pl  2522 [000]  6011.824759: block:block_rq_issue: 254,16 R 0 () 7322849 + 16 [randread.pl]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     randread.pl  2520 [000]  6011.824866: block:block_rq_issue: 254,16 R 0 () 26144801 + 16 [randread.pl]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         swapper     0 [000]  6011.828913: block:block_rq_complete: 254,16 R () 31262577 + 16 [0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     randread.pl  2521 [000]  6011.828970: block:block_rq_issue: 254,16 R 0 () 70295937 + 16 [randread.pl]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         swapper     0 [000]  6011.835862: block:block_rq_complete: 254,16 R () 26144801 + 16 [0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     randread.pl  2520 [000]  6011.835932: block:block_rq_issue: 254,16 R 0 () 5495681 + 16 [randread.pl]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         swapper     0 [000]  6011.837988: block:block_rq_complete: 254,16 R () 7322849 + 16 [0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     randread.pl  2522 [000]  6011.838051: block:block_rq_issue: 254,16 R 0 () 108589633 + 16 [randread.pl]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         swapper     0 [000]  6011.850615: block:block_rq_complete: 254,16 R () 108589633 + 16 [0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>The full output from perf script is about 70,000 lines. I&#x27;ve included some here so that you can see the kind of data available.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="processing">Processing<a href="#processing" class="hash-link" aria-label="Processing的直接链接" title="Processing的直接链接" translate="no">​</a></h3>
<p>To calculate latency for each I/O, I&#x27;ll need to pair up the issue and completion events, so that I can calculate the timestamp delta. The columns look straightforward (and are in include/trace/events/block.h), with the 4th field the timestamp in seconds (with microsecond resolution), the 6th field the disk device ID (major, minor), and a later field (which varies based on the tracepoint) has the disk offset. I&#x27;ll use the disk device ID and offset as the unique identifier, assuming the kernel will not issue concurrent I/O to the exact same location.</p>
<p>I&#x27;ll use awk to do these calculations and print the completion times and latency:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf script | awk &#x27;{ gsub(/:/, &quot;&quot;) } $5 ~ /issue/ { ts[$6, $10] = $4 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    $5 ~ /complete/ { if (l = ts[$6, $9]) { printf &quot;%.f %.f\n&quot;, $4 * 1000000,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($4 - l) * 1000000; ts[$6, $10] = 0 } }&#x27; &gt; out.lat_us</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># more out.lat_us</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6011793689 8437</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6011797306 3488</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6011798851 1283</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6011806422 11248</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6011824680 18210</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6011824693 21908</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>I converted both columns to be microseconds, to make the next step easier.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="generation-1">Generation<a href="#generation-1" class="hash-link" aria-label="Generation的直接链接" title="Generation的直接链接" translate="no">​</a></h3>
<p>Now I can use my trace2heatmap.pl program (<a href="https://github.com/brendangregg/HeatMap" target="_blank" rel="noopener noreferrer">github</a>), to generate the interactive SVG heatmap from the trace data (and uses microseconds by default):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># ./trace2heatmap.pl --unitstime=us --unitslat=us --maxlat=50000 out.lat_us &gt; out.svg</span><br></span></code></pre></div></div>
<p>When I generated the heatmap, I truncated the y scale to 50 ms. You can adjust it to suit your investigation, increasing it to see more of the latency outliers, or decreasing it to reveal more resolution for the lower latencies: for example, with a <a href="https://www.brendangregg.com/perf_events/perf_block_latencyheatmap2.svg" target="_blank" rel="noopener noreferrer">250 us limit</a>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="overheads">Overheads<a href="#overheads" class="hash-link" aria-label="Overheads的直接链接" title="Overheads的直接链接" translate="no">​</a></h3>
<p>While this can be useful to do, be mindful of overheads. In my case, I had a low rate of disk I/O (~300 IOPS), which generated an 8 Mbyte trace file after 2 minutes. If your disk IOPS were 100x that, your trace file will also be 100x, and the overheads for gathering and processing will add up.</p>
<p>For more about latency heatmaps, see my <a href="http://www.slideshare.net/brendangregg/lisa2010-visualizations" target="_blank" rel="noopener noreferrer">LISA 2010</a> presentation slides, and my <a href="http://cacm.acm.org/magazines/2010/7/95062-visualizing-system-latency/fulltext" target="_blank" rel="noopener noreferrer">CACM 2010</a> article, both about heat maps. Also see my <a href="https://www.brendangregg.com/blog/2014-07-01/perf-heat-maps.html" target="_blank" rel="noopener noreferrer">Perf Heat Maps</a> blog post.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="8-targets">8. Targets<a href="#8-targets" class="hash-link" aria-label="8. Targets的直接链接" title="8. Targets的直接链接" translate="no">​</a></h2>
<p>Notes on specific targets.</p>
<p>Under construction.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="81-java">8.1. Java<a href="#81-java" class="hash-link" aria-label="8.1. Java的直接链接" title="8.1. Java的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="82-nodejs">8.2. Node.js<a href="#82-nodejs" class="hash-link" aria-label="8.2. Node.js的直接链接" title="8.2. Node.js的直接链接" translate="no">​</a></h2>
<ul>
<li>Node.js V8 JIT internals with annotation support <a href="https://twitter.com/brendangregg/status/755838455549001728" target="_blank" rel="noopener noreferrer">https://twitter.com/brendangregg/status/755838455549001728</a></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="9-more">9. More<a href="#9-more" class="hash-link" aria-label="9. More的直接链接" title="9. More的直接链接" translate="no">​</a></h2>
<p>There&#x27;s more capabilities to perf_events than I&#x27;ve demonstrated here. I&#x27;ll add examples of the other subcommands when I get a chance.</p>
<p>Here&#x27;s a preview of perf trace, which was added in <a href="http://kernelnewbies.org/Linux_3.7" target="_blank" rel="noopener noreferrer">3.7</a>, demonstrated on 3.13.1:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># perf trace ls</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.109 ( 0.000 ms):  ... [continued]: read()) = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.430 ( 0.000 ms):  ... [continued]: execve()) = -2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.565 ( 0.051 ms): execve(arg0: 140734989338352, arg1: 140734989358048, arg2: 40612288, arg3: 1407...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.697 ( 0.051 ms): execve(arg0: 140734989338353, arg1: 140734989358048, arg2: 40612288, arg3: 1407...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.797 ( 0.046 ms): execve(arg0: 140734989338358, arg1: 140734989358048, arg2: 40612288, arg3: 1407...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.915 ( 0.045 ms): execve(arg0: 140734989338359, arg1: 140734989358048, arg2: 40612288, arg3: 1407...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1.030 ( 0.044 ms): execve(arg0: 140734989338362, arg1: 140734989358048, arg2: 40612288, arg3: 1407...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     1.414 ( 0.311 ms): execve(arg0: 140734989338363, arg1: 140734989358048, arg2: 40612288, arg3: 1407...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     2.156 ( 1.053 ms):  ... [continued]: brk()) = 0xac9000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     2.319 ( 1.215 ms):  ... [continued]: access()) = -1 ENOENT No such file or directory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     2.479 ( 1.376 ms):  ... [continued]: mmap()) = 0xb3a84000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     2.634 ( 0.052 ms): access(arg0: 139967406289504, arg1: 4, arg2: 139967408408688, arg3: 13996740839...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     2.787 ( 0.205 ms):  ... [continued]: open()) = 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     2.919 ( 0.337 ms):  ... [continued]: fstat()) = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     3.049 ( 0.057 ms): mmap(arg0: 0, arg1: 22200, arg2: 1, arg3: 2, arg4: 3, arg5: 0         ) = 0xb3a...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     3.177 ( 0.184 ms):  ... [continued]: close()) = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     3.298 ( 0.043 ms): access(arg0: 139967406278152, arg1: 0, arg2: 6, arg3: 7146772199173811245, arg4...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     3.432 ( 0.049 ms): open(arg0: 139967408376811, arg1: 524288, arg2: 0, arg3: 139967408376810, arg4:...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     3.560 ( 0.045 ms): read(arg0: 3, arg1: 140737350651528, arg2: 832, arg3: 139967408376810, arg4: 14...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     3.684 ( 0.042 ms): fstat(arg0: 3, arg1: 140737350651216, arg2: 140737350651216, arg3: 354389249727...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     3.814 ( 0.054 ms): mmap(arg0: 0, arg1: 2221680, arg2: 5, arg3: 2050, arg4: 3, arg5: 0    ) = 0xb36...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[...]</span><br></span></code></pre></div></div>
<p>An advantage is that this is buffered tracing, which costs much less overhead than strace, as I described <a href="https://www.brendangregg.com/#perf_vs_strace" target="_blank" rel="noopener noreferrer">earlier</a>. The perf trace output seen from this 3.13.1 kernel does, however, looks suspicious for a number of reasons. I think this is still an in-development feature. It reminds me of my <a href="http://www.brendangregg.com/dtrace.html#dtruss" target="_blank" rel="noopener noreferrer">dtruss</a> tool, which has a similar role, before I added code to print each system call in a custom and appropriate way.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="10-building">10. Building<a href="#10-building" class="hash-link" aria-label="10. Building的直接链接" title="10. Building的直接链接" translate="no">​</a></h2>
<p>The steps to build perf_events depends on your kernel version and Linux distribution. In summary:</p>
<ol>
<li>Get the Linux kernel source that matches your currently running kernel (eg, from the linux-source package, or <a href="http://kernel.org/" target="_blank" rel="noopener noreferrer">kernel.org</a>).</li>
<li>Unpack the kernel source.</li>
<li>cd tools/perf</li>
<li>make</li>
<li>Fix all errors, and most warnings, from (4).</li>
</ol>
<p>The first error may be that you are missing make, or a compiler (gcc). Once you have those, you may then see various warnings about missing libraries, which disable perf features. I&#x27;d install as many as possible, and take note of the ones you are missing.</p>
<p>These perf build warnings are <em>really helpful</em>, and are generated by its Makefile. Here&#x27;s the makefile from 3.9.3:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># grep found Makefile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(warning No libelf found, disables &#x27;probe&#x27; tool, please install elfutils-libelf-devel/libelf-dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(error No gnu/libc-version.h found, please install glibc-dev[el]/glibc-static);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(warning No libdw.h found or old libdw.h found or elfutils is older than 0.138, disables dwarf support.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Please install new elfutils-devel/libdw-dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(warning No libunwind found, disabling post unwind support. Please install libunwind-dev[el] &gt;= 0.99);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(warning No libaudit.h found, disables &#x27;trace&#x27; tool, please install audit-libs-devel or libaudit-dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(warning newt not found, disables TUI support. Please install newt-devel or libnewt-dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(warning GTK2 not found, disables GTK2 support. Please install gtk2-devel or libgtk2.0-dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$(if $(1),$(warning No $(1) was found))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(warning No bfd.h/libbfd found, install binutils-dev[el]/zlib-static to gain symbol demangling)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msg := $(warning No numa.h found, disables &#x27;perf bench numa mem&#x27; benchmark, please install numa-libs-devel or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> libnuma-dev);</span><br></span></code></pre></div></div>
<p>Take the time to read them. This list is likely to grow as new features are added to perf_events.</p>
<p>The following notes show what I&#x27;ve specifically done for kernel versions and distributions, in case it is helpful.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="packages-ubuntu-386">Packages: Ubuntu, 3.8.6<a href="#packages-ubuntu-386" class="hash-link" aria-label="Packages: Ubuntu, 3.8.6的直接链接" title="Packages: Ubuntu, 3.8.6的直接链接" translate="no">​</a></h3>
<p>Packages required for key functionality: gcc make bison flex elfutils libelf-dev libdw-dev libaudit-dev. You may also consider python-dev (for python scripting) and binutils-dev (for symbol demangling), which are larger packages.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kernel-config-386">Kernel Config: 3.8.6<a href="#kernel-config-386" class="hash-link" aria-label="Kernel Config: 3.8.6的直接链接" title="Kernel Config: 3.8.6的直接链接" translate="no">​</a></h3>
<p>Here are some kernel CONFIG options for perf_events functionality:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># for perf_events:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_PERF_EVENTS=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># for stack traces:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_FRAME_POINTER=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># kernel symbols:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_KALLSYMS=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># tracepoints:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_TRACEPOINTS=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># kernel function trace:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_FTRACE=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># kernel-level dynamic tracing:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_KPROBES=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_KPROBE_EVENTS=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># user-level dynamic tracing:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_UPROBES=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_UPROBE_EVENTS=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># full kernel debug info:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_DEBUG_INFO=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># kernel lock tracing:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_LOCKDEP=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># kernel lock tracing:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_LOCK_STAT=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># kernel dynamic tracepoint variables:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_DEBUG_INFO=y</span><br></span></code></pre></div></div>
<p>You may need to build your own kernel to enable these. The exact set you need depends on your needs and kernel version, and list is likely to grow as new features are added to perf_events.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="101-static-builds">10.1. Static Builds<a href="#101-static-builds" class="hash-link" aria-label="10.1. Static Builds的直接链接" title="10.1. Static Builds的直接链接" translate="no">​</a></h2>
<p>I&#x27;ve sometimes done this so that I have a single perf binary that can be copied into Docker containers for execution. Steps, given the Linux source:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cd tools/perf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vi Makefile.perf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  LDFLAGS=-static</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">make clean; make</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="11-troubleshooting">11. Troubleshooting<a href="#11-troubleshooting" class="hash-link" aria-label="11. Troubleshooting的直接链接" title="11. Troubleshooting的直接链接" translate="no">​</a></h2>
<p>If you see hexadecimal numbers instead of symbols, or have truncated stack traces, see the <a href="https://www.brendangregg.com/#Prerequisites" target="_blank" rel="noopener noreferrer">Prerequisites</a> section.</p>
<p>Here are some rough notes from other issues I&#x27;ve encountered.</p>
<p>This sometimes works (3.5.7.2) and sometimes throws the following error (3.9.3):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ubuntu# perf stat -e &#x27;syscalls:sys_enter_*&#x27; -a sleep 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Error:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Too many events are opened.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Try again after reducing the number of events.</span><br></span></code></pre></div></div>
<p>This can be fixed by increasing the file descriptor limit using ulimit -n.</p>
<p>Type 3 errors:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ubuntu# perf report</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0xab7e48 [0x30]: failed to process type: 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># captured on: Tue Jan 28 21:08:31 2014</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># hostname : pgbackup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># os release : 3.9.3-ubuntu-12-opt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># perf version : 3.9.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># arch : x86_64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus online : 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># nrcpus avail : 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpudesc : Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cpuid : GenuineIntel,6,45,7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># total memory : 8179104 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cmdline : /lib/modules/3.9.3-ubuntu-12-opt/build/tools/perf/perf record</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> -e sched:sched_process_exec -a </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># event : name = sched:sched_process_exec, type = 2, config = 0x125, config1 = 0x0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> config2 = 0x0, excl_usr = 0, excl_kern = 0, excl_host = 0, excl_guest = 1, precise_ip = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_CPU_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># HEADER_NUMA_TOPOLOGY info available, use -I to display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># pmu mappings: software = 1, tracepoint = 2, breakpoint = 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Warning: Timestamp below last timeslice flush</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="12-other-tools">12. Other Tools<a href="#12-other-tools" class="hash-link" aria-label="12. Other Tools的直接链接" title="12. Other Tools的直接链接" translate="no">​</a></h2>
<p>perf_events has the capabilities from many other tools rolled into one: strace(1), for tracing system calls, tcpdump(8), for tracing network packets, and blktrace(1), for tracing block device I/O (disk I/O), and other targets including file system and scheduler events. Tracing all events from one tool is not only convenient, it also allows direct correlations, including timestamps, between different instrumentation sources. Unlike these other tools, some assembly is required, which may not be for everyone (as explained in <a href="https://www.brendangregg.com/#Audience" target="_blank" rel="noopener noreferrer">Audience</a>).</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="13-resources">13. Resources<a href="#13-resources" class="hash-link" aria-label="13. Resources的直接链接" title="13. Resources的直接链接" translate="no">​</a></h2>
<p>Resources for further study.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="131-posts">13.1. Posts<a href="#131-posts" class="hash-link" aria-label="13.1. Posts的直接链接" title="13.1. Posts的直接链接" translate="no">​</a></h2>
<p>I&#x27;ve been writing blog posts on specific perf_events topics. My suggested reading order is from oldest to newest (top down):</p>
<ul>
<li>22 Jun 2014: <a href="https://www.brendangregg.com/blog/2014-06-22/perf-cpu-sample.html" target="_blank" rel="noopener noreferrer">perf CPU Sampling</a></li>
<li>29 Jun 2014: <a href="https://www.brendangregg.com/blog/2014-06-29/perf-static-tracepoints.html" target="_blank" rel="noopener noreferrer">perf Static Tracepoints</a></li>
<li>01 Jul 2014: <a href="https://www.brendangregg.com/blog/2014-07-01/perf-heat-maps.html" target="_blank" rel="noopener noreferrer">perf Heat Maps</a></li>
<li>03 Jul 2014: <a href="https://www.brendangregg.com/blog/2014-07-03/perf-counting.html" target="_blank" rel="noopener noreferrer">perf Counting</a></li>
<li>10 Jul 2014: <a href="https://www.brendangregg.com/blog/2014-07-10/perf-hacktogram.html" target="_blank" rel="noopener noreferrer">perf Hacktogram</a></li>
<li>11 Sep 2014: <a href="https://www.brendangregg.com/blog/2014-09-11/perf-kernel-line-tracing.html" target="_blank" rel="noopener noreferrer">Linux perf Rides the Rocket: perf Kernel Line Tracing</a></li>
<li>17 Sep 2014: <a href="https://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html" target="_blank" rel="noopener noreferrer">node.js Flame Graphs on Linux</a></li>
<li>26 Feb 2015: <a href="https://www.brendangregg.com/blog/2015-02-26/linux-perf-off-cpu-flame-graph.html" target="_blank" rel="noopener noreferrer">Linux perf_events Off-CPU Time Flame Graph</a></li>
<li>27 Feb 2015: <a href="https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html" target="_blank" rel="noopener noreferrer">Linux Profiling at Netflix</a></li>
<li>24 Jul 2015: <a href="http://techblog.netflix.com/2015/07/java-in-flames.html" target="_blank" rel="noopener noreferrer">Java Mixed-Mode Flame Graphs</a> (<a href="https://www.brendangregg.com/Articles/Netflix_Java_in_Flames.pdf" target="_blank" rel="noopener noreferrer">PDF</a>)</li>
<li>30 Apr 2016: <a href="https://www.brendangregg.com/blog/2016-04-30/linux-perf-folded.html" target="_blank" rel="noopener noreferrer">Linux 4.5 perf folded format</a></li>
</ul>
<p>And posts on ftrace:</p>
<ul>
<li>13 Jul 2014: <a href="https://www.brendangregg.com/blog/2014-07-13/linux-ftrace-function-counting.html" target="_blank" rel="noopener noreferrer">Linux ftrace Function Counting</a></li>
<li>16 Jul 2014: <a href="https://www.brendangregg.com/blog/2014-07-16/iosnoop-for-linux.html" target="_blank" rel="noopener noreferrer">iosnoop for Linux</a></li>
<li>23 Jul 2014: <a href="https://www.brendangregg.com/blog/2014-07-23/linux-iosnoop-latency-heat-maps.html" target="_blank" rel="noopener noreferrer">Linux iosnoop Latency Heat Maps</a></li>
<li>25 Jul 2014: <a href="https://www.brendangregg.com/blog/2014-07-25/opensnoop-for-linux.html" target="_blank" rel="noopener noreferrer">opensnoop for Linux</a></li>
<li>28 Jul 2014: <a href="https://www.brendangregg.com/blog/2014-07-28/execsnoop-for-linux.html" target="_blank" rel="noopener noreferrer">execsnoop for Linux: See Short-Lived Processes</a></li>
<li>30 Aug 2014: <a href="https://www.brendangregg.com/blog/2014-08-30/ftrace-the-hidden-light-switch.html" target="_blank" rel="noopener noreferrer">ftrace: The Hidden Light Switch</a></li>
<li>06 Sep 2014: <a href="https://www.brendangregg.com/blog/2014-09-06/linux-ftrace-tcp-retransmit-tracing.html" target="_blank" rel="noopener noreferrer">tcpretrans: Tracing TCP retransmits</a></li>
<li>31 Dec 2014: <a href="https://www.brendangregg.com/blog/2014-12-31/linux-page-cache-hit-ratio.html" target="_blank" rel="noopener noreferrer">Linux Page Cache Hit Ratio</a></li>
<li>28 Jun 2015: <a href="https://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html" target="_blank" rel="noopener noreferrer">uprobe: User-Level Dynamic Tracing</a></li>
<li>03 Jul 2015: <a href="https://www.brendangregg.com/blog/2015-07-03/hacking-linux-usdt-ftrace.html" target="_blank" rel="noopener noreferrer">Hacking Linux USDT</a></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="132-links">13.2. Links<a href="#132-links" class="hash-link" aria-label="13.2. Links的直接链接" title="13.2. Links的直接链接" translate="no">​</a></h2>
<p>perf_events:</p>
<ul>
<li><a href="https://github.com/brendangregg/perf-tools" target="_blank" rel="noopener noreferrer">perf-tools</a> (github), a collection of my performance analysis tools based on Linux perf_events and ftrace.</li>
<li><a href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="noopener noreferrer">perf Main Page</a>.</li>
<li>The excellent <a href="https://perf.wiki.kernel.org/index.php/Tutorial" target="_blank" rel="noopener noreferrer">perf Tutorial</a>, which focuses more on CPU hardware counters.</li>
<li>The <a href="http://web.eece.maine.edu/~vweaver/projects/perf_events/" target="_blank" rel="noopener noreferrer">Unofficial Linux Perf Events Web-Page</a> by Vince Weaver.</li>
<li>The <a href="http://dir.gmane.org/gmane.linux.kernel.perf.user" target="_blank" rel="noopener noreferrer">perf user</a> mailing list.</li>
<li>Mischa Jonker&#x27;s presentation <a href="http://events.linuxfoundation.org/sites/events/files/slides/ELCE%20-%20fighting%20latency.pdf" target="_blank" rel="noopener noreferrer">Fighting latency: How to optimize your system using perf</a> (PDF) (2013).</li>
<li>The <a href="http://skreened.com/rexlambo/omg-so-perf" target="_blank" rel="noopener noreferrer">OMG SO PERF T-shirt</a> (site has coarse language).</li>
<li>Shannon Cepeda&#x27;s great posts on pipeline speak: <a href="http://software.intel.com/en-us/blogs/2011/11/22/pipeline-speak-learning-more-about-intel-microarchitecture-codename-sandy-bridge" target="_blank" rel="noopener noreferrer">frontend</a> and <a href="http://software.intel.com/en-us/blogs/2011/12/01/pipeline-speak-part-2-the-second-part-of-the-sandy-bridge-pipeline" target="_blank" rel="noopener noreferrer">backend.</a></li>
<li>Jiri Olsa&#x27;s <a href="https://lkml.org/lkml/2012/4/17/165" target="_blank" rel="noopener noreferrer">dwarf mode callchain</a> patch.</li>
<li>Linux kernel source: <a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/examples.txt" target="_blank" rel="noopener noreferrer">tools/perf/Documentation/examples.txt</a>.</li>
<li>Linux kernel source: <a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/perf-record.txt" target="_blank" rel="noopener noreferrer">tools/perf/Documentation/perf-record.txt</a>.</li>
<li>... and other documentation under tools/perf/Documentation.</li>
<li>A good case study for <a href="https://alexandrnikitin.github.io/blog/transparent-hugepages-measuring-the-performance-impact/" target="_blank" rel="noopener noreferrer">Transparent Hugepages: measuring the performance impact</a> using perf and PMCs.</li>
<li>Julia Evans created a <a href="https://twitter.com/b0rk/status/945900285460926464" target="_blank" rel="noopener noreferrer">perf cheatsheet</a> based on my one-liners (2017).</li>
<li>Denis Bakhvalov has a great post on <a href="https://easyperf.net/blog/2018/06/08/Advanced-profiling-topics-PEBS-and-LBR" target="_blank" rel="noopener noreferrer">PEBS and LBR internals</a>.</li>
</ul>
<p>ftrace:</p>
<ul>
<li><a href="https://github.com/brendangregg/perf-tools" target="_blank" rel="noopener noreferrer">perf-tools</a> (github), a collection of my performance analysis tools based on Linux perf_events and ftrace.</li>
<li><a href="https://lwn.net/Articles/608497/" target="_blank" rel="noopener noreferrer">Ftrace: The hidden light switch</a>, by myself for lwn.net, Aug 2014.</li>
<li>Linux kernel source: <a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/trace/ftrace.txt" target="_blank" rel="noopener noreferrer">Documentation/trace/ftrace.txt</a>.</li>
<li>lwn.net <a href="http://lwn.net/Articles/370423/" target="_blank" rel="noopener noreferrer">Secrets of the Ftrace function tracer</a>, by Steven Rostedt, Jan 2010.</li>
<li>lwn.net <a href="http://lwn.net/Articles/365835/" target="_blank" rel="noopener noreferrer">Debugging the kernel using Ftrace - part 1</a>, by Steven Rostedt, Dec 2009.</li>
<li>lwn.net <a href="http://lwn.net/Articles/366796/" target="_blank" rel="noopener noreferrer">Debugging the kernel using Ftrace - part 2</a>, by Steven Rostedt, Dec 2009.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="14-email">14. Email<a href="#14-email" class="hash-link" aria-label="14. Email的直接链接" title="14. Email的直接链接" translate="no">​</a></h2>
<p>Have a question? If you work at Netflix, contact me. If not, please use the <a href="http://dir.gmane.org/gmane.linux.kernel.perf.user" target="_blank" rel="noopener noreferrer">perf user</a> mailing list, which I and other perf users are on.</p>
<hr>
<p>Site Navigation</p>
<p>Brendan&#x27;s site:</p>
<p><a href="https://www.brendangregg.com/overview.html" target="_blank" rel="noopener noreferrer">Start Here</a><br>
<a href="https://www.brendangregg.com/index.html" target="_blank" rel="noopener noreferrer">Homepage</a><br>
<a href="https://www.brendangregg.com/blog/index.html" target="_blank" rel="noopener noreferrer">Blog</a><br>
<a href="https://www.brendangregg.com/systems-performance-2nd-edition-book.html" target="_blank" rel="noopener noreferrer">Sys Perf book</a><br>
<a href="https://www.brendangregg.com/bpf-performance-tools-book.html" target="_blank" rel="noopener noreferrer">BPF Perf book</a><br>
<a href="https://www.brendangregg.com/linuxperf.html" target="_blank" rel="noopener noreferrer">Linux Perf</a><br>
<a href="https://www.brendangregg.com/ebpf.html" target="_blank" rel="noopener noreferrer">eBPF Tools</a><br>
<a href="https://www.brendangregg.com/perf.html" target="_blank" rel="noopener noreferrer">perf Examples</a><br>
<a href="https://www.brendangregg.com/methodology.html" target="_blank" rel="noopener noreferrer">Perf Methods</a><br>
<a href="https://www.brendangregg.com/usemethod.html" target="_blank" rel="noopener noreferrer">USE Method</a><br>
<a href="https://www.brendangregg.com/tsamethod.html" target="_blank" rel="noopener noreferrer">TSA Method</a><br>
<a href="https://www.brendangregg.com/offcpuanalysis.html" target="_blank" rel="noopener noreferrer">Off-CPU Analysis</a><br>
<a href="https://www.brendangregg.com/activebenchmarking.html" target="_blank" rel="noopener noreferrer">Active Bench.</a><br>
<a href="https://www.brendangregg.com/wss.html" target="_blank" rel="noopener noreferrer">WSS Estimation</a><br>
<a href="https://www.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener noreferrer">Flame Graphs</a><br>
<a href="https://www.brendangregg.com/flamescope.html" target="_blank" rel="noopener noreferrer">Flame Scope</a><br>
<a href="https://www.brendangregg.com/heatmaps.html" target="_blank" rel="noopener noreferrer">Heat Maps</a><br>
<a href="https://www.brendangregg.com/frequencytrails.html" target="_blank" rel="noopener noreferrer">Frequency Trails</a><br>
<a href="https://www.brendangregg.com/colonygraphs.html" target="_blank" rel="noopener noreferrer">Colony Graphs</a><br>
<a href="https://www.brendangregg.com/dtrace.html" target="_blank" rel="noopener noreferrer">DTrace Tools</a><br>
<a href="https://www.brendangregg.com/dtracetoolkit.html" target="_blank" rel="noopener noreferrer">DTraceToolkit</a><br>
<a href="https://www.brendangregg.com/dtkshdemos.html" target="_blank" rel="noopener noreferrer">DtkshDemos</a><br>
<a href="https://www.brendangregg.com/guessinggame.html" target="_blank" rel="noopener noreferrer">Guessing Game</a><br>
<a href="https://www.brendangregg.com/specials.html" target="_blank" rel="noopener noreferrer">Specials</a><br>
<a href="https://www.brendangregg.com/books.html" target="_blank" rel="noopener noreferrer">Books</a><br>
<a href="https://www.brendangregg.com/sites.html" target="_blank" rel="noopener noreferrer">Other Sites</a></p>
<hr>
<p><a href="https://www.brendangregg.com/systems-performance-2nd-edition-book.html" target="_blank" rel="noopener noreferrer"><img decoding="async" loading="lazy" src="/assets/images/543949b8fa40af4f1cb4315aabb88eda_MD5-88b4c91525c322648e4275880bf7609c.jpg" width="360" height="470" class="img_ev3q"></a><br>
<em><a href="https://www.brendangregg.com/systems-performance-2nd-edition-book.html" target="_blank" rel="noopener noreferrer">Systems Performance 2nd Ed.</a></em></p>
<p><a href="https://www.brendangregg.com/bpf-performance-tools-book.html" target="_blank" rel="noopener noreferrer"><img decoding="async" loading="lazy" src="/assets/images/a507657135cfc949e59c8999248f1025_MD5-7d8af572352b06f4210a1ddba83d8f04.jpg" width="360" height="468" class="img_ev3q"></a><br>
<em><a href="https://www.brendangregg.com/bpf-performance-tools-book.html" target="_blank" rel="noopener noreferrer">BPF Performance Tools book</a></em></p>
<p>Recent posts:</p>
<ul>
<li>22 May 2025 »<br>
<a href="https://www.brendangregg.com/blog/2025-05-22/3-years-of-extremely-remote-work.html" target="_blank" rel="noopener noreferrer">3 Years of Extremely Remote Work</a>
<ul>
<li>01 May 2025 »<br>
<a href="https://www.brendangregg.com/blog/2025-05-01/doom-gpu-flame-graphs.html" target="_blank" rel="noopener noreferrer">Doom GPU Flame Graphs</a></li>
<li>29 Oct 2024 »<br>
<a href="https://www.brendangregg.com/blog/2024-10-29/ai-flame-graphs.html" target="_blank" rel="noopener noreferrer">AI Flame Graphs</a></li>
<li>22 Jul 2024 »<br>
<a href="https://www.brendangregg.com/blog/2024-07-22/no-more-blue-fridays.html" target="_blank" rel="noopener noreferrer">No More Blue Fridays</a></li>
<li>24 Mar 2024 »<br>
<a href="https://www.brendangregg.com/blog/2024-03-24/linux-crisis-tools.html" target="_blank" rel="noopener noreferrer">Linux Crisis Tools</a></li>
<li>17 Mar 2024 »<br>
<a href="https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html" target="_blank" rel="noopener noreferrer">The Return of the Frame Pointers</a></li>
<li>10 Mar 2024 »<br>
<a href="https://www.brendangregg.com/blog/2024-03-10/ebpf-documentary.html" target="_blank" rel="noopener noreferrer">eBPF Documentary</a></li>
<li>28 Apr 2023 »<br>
<a href="https://www.brendangregg.com/blog/2023-04-28/ebpf-security-issues.html" target="_blank" rel="noopener noreferrer">eBPF Observability Tools Are Not Security Tools</a></li>
<li>01 Mar 2023 »<br>
<a href="https://www.brendangregg.com/blog/2023-03-01/computer-performance-future-2022.html" target="_blank" rel="noopener noreferrer">USENIX SREcon APAC 2022: Computing Performance: What&#x27;s on the Horizon</a></li>
<li>17 Feb 2023 »<br>
<a href="https://www.brendangregg.com/blog/2023-02-17/srecon-apac-2023.html" target="_blank" rel="noopener noreferrer">USENIX SREcon APAC 2023: CFP</a></li>
<li>02 May 2022 »<br>
<a href="https://www.brendangregg.com/blog/2022-05-02/brendan-at-intel.html" target="_blank" rel="noopener noreferrer">Brendan@Intel.com</a></li>
<li>15 Apr 2022 »<br>
<a href="https://www.brendangregg.com/blog/2022-04-15/netflix-farewell-1.html" target="_blank" rel="noopener noreferrer">Netflix End of Series 1</a></li>
<li>09 Apr 2022 »<br>
<a href="https://www.brendangregg.com/blog/2022-04-09/tensorflow-library-performance.html" target="_blank" rel="noopener noreferrer">TensorFlow Library Performance</a></li>
<li>19 Mar 2022 »<br>
<a href="https://www.brendangregg.com/blog/2022-03-19/why-dont-you-use.html" target="_blank" rel="noopener noreferrer">Why Don&#x27;t You Use...</a></li>
<li>26 Sep 2021 »<br>
<a href="https://www.brendangregg.com/blog/2021-09-26/the-speed-of-time.html" target="_blank" rel="noopener noreferrer">The Speed of Time</a></li>
<li>06 Sep 2021 »<br>
<a href="https://www.brendangregg.com/blog/2021-09-06/zfs-is-mysteriously-eating-my-cpu.html" target="_blank" rel="noopener noreferrer">ZFS Is Mysteriously Eating My CPU</a></li>
<li>30 Aug 2021 »<br>
<a href="https://www.brendangregg.com/blog/2021-08-30/high-rate-of-paging.html" target="_blank" rel="noopener noreferrer">Analyzing a High Rate of Paging</a></li>
<li>27 Aug 2021 »<br>
<a href="https://www.brendangregg.com/blog/2021-08-27/slack-crashes-secret-stderr.html" target="_blank" rel="noopener noreferrer">Slack&#x27;s Secret STDERR Messages</a></li>
<li>05 Jul 2021 »<br>
<a href="https://www.brendangregg.com/blog/2021-07-05/computing-performance-on-the-horizon.html" target="_blank" rel="noopener noreferrer">USENIX LISA2021 Computing Performance: On the Horizon</a></li>
<li>03 Jul 2021 »<br>
<a href="https://www.brendangregg.com/blog/2021-07-03/how-to-add-bpf-observability.html" target="_blank" rel="noopener noreferrer">How To Add eBPF Observability To Your Product</a>
<a href="https://www.brendangregg.com/blog/index.html" target="_blank" rel="noopener noreferrer">Blog index</a><br>
<a href="https://www.brendangregg.com/blog/about.html" target="_blank" rel="noopener noreferrer">About</a><br>
<a href="https://www.brendangregg.com/blog/rss.xml" target="_blank" rel="noopener noreferrer">RSS</a></li>
</ul>
</li>
</ul>
<hr>
<p>Last Updated: 29-Jul-2020<br>
<!-- -->Copyright 2020 Brendan Gregg</p></div></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="文件选项卡"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#linux-perf-examples" class="table-of-contents__link toc-highlight">Linux perf Examples</a></li><li><a href="#1-screenshot" class="table-of-contents__link toc-highlight">1. Screenshot</a></li><li><a href="#2-one-liners" class="table-of-contents__link toc-highlight">2. One-Liners</a><ul><li><a href="#listing-events" class="table-of-contents__link toc-highlight">Listing Events</a></li><li><a href="#counting-events" class="table-of-contents__link toc-highlight">Counting Events</a></li><li><a href="#profiling" class="table-of-contents__link toc-highlight">Profiling</a></li><li><a href="#static-tracing" class="table-of-contents__link toc-highlight">Static Tracing</a></li><li><a href="#dynamic-tracing" class="table-of-contents__link toc-highlight">Dynamic Tracing</a></li><li><a href="#mixed" class="table-of-contents__link toc-highlight">Mixed</a></li><li><a href="#special" class="table-of-contents__link toc-highlight">Special</a></li><li><a href="#reporting" class="table-of-contents__link toc-highlight">Reporting</a></li></ul></li><li><a href="#3-presentations" class="table-of-contents__link toc-highlight">3. Presentations</a><ul><li><a href="#kernel-recipes-2017" class="table-of-contents__link toc-highlight">Kernel Recipes (2017)</a></li></ul></li><li><a href="#4-background" class="table-of-contents__link toc-highlight">4. Background</a></li><li><a href="#41-prerequisites" class="table-of-contents__link toc-highlight">4.1. Prerequisites</a></li><li><a href="#42-symbols" class="table-of-contents__link toc-highlight">4.2. Symbols</a></li><li><a href="#43-jit-symbols-java-nodejs" class="table-of-contents__link toc-highlight">4.3. JIT Symbols (Java, Node.js)</a></li><li><a href="#44-stack-traces" class="table-of-contents__link toc-highlight">4.4 Stack Traces</a></li><li><a href="#45-audience" class="table-of-contents__link toc-highlight">4.5. Audience</a></li><li><a href="#46-usage" class="table-of-contents__link toc-highlight">4.6. Usage</a></li><li><a href="#47-usage-examples" class="table-of-contents__link toc-highlight">4.7. Usage Examples</a><ul><li><a href="#caveats" class="table-of-contents__link toc-highlight">Caveats</a></li></ul></li><li><a href="#48-special-usage" class="table-of-contents__link toc-highlight">4.8. Special Usage</a></li><li><a href="#5-events" class="table-of-contents__link toc-highlight">5. Events</a></li><li><a href="#51-software-events" class="table-of-contents__link toc-highlight">5.1. Software Events</a></li><li><a href="#52-hardware-events-pmcs" class="table-of-contents__link toc-highlight">5.2. Hardware Events (PMCs)</a></li><li><a href="#53-kernel-tracepoints" class="table-of-contents__link toc-highlight">5.3. Kernel Tracepoints</a></li><li><a href="#54-user-level-statically-defined-tracing-usdt" class="table-of-contents__link toc-highlight">5.4. User-Level Statically Defined Tracing (USDT)</a></li><li><a href="#55-dynamic-tracing" class="table-of-contents__link toc-highlight">5.5. Dynamic Tracing</a></li><li><a href="#6-examples" class="table-of-contents__link toc-highlight">6. Examples</a></li><li><a href="#61-cpu-statistics" class="table-of-contents__link toc-highlight">6.1. CPU Statistics</a><ul><li><a href="#cpu-microarchitecture" class="table-of-contents__link toc-highlight">CPU Microarchitecture</a></li><li><a href="#detailed-mode" class="table-of-contents__link toc-highlight">Detailed Mode</a></li><li><a href="#specific-counters" class="table-of-contents__link toc-highlight">Specific Counters</a></li><li><a href="#raw-counters" class="table-of-contents__link toc-highlight">Raw Counters</a></li><li><a href="#other-options" class="table-of-contents__link toc-highlight">Other Options</a></li></ul></li><li><a href="#62-timed-profiling" class="table-of-contents__link toc-highlight">6.2. Timed Profiling</a></li><li><a href="#63-event-profiling" class="table-of-contents__link toc-highlight">6.3. Event Profiling</a><ul><li><a href="#skew-and-pebs" class="table-of-contents__link toc-highlight">Skew and PEBS</a></li></ul></li><li><a href="#64-static-kernel-tracing" class="table-of-contents__link toc-highlight">6.4. Static Kernel Tracing</a><ul><li><a href="#counting-syscalls" class="table-of-contents__link toc-highlight">Counting Syscalls</a></li><li><a href="#perf-vs-strace" class="table-of-contents__link toc-highlight">perf vs strace</a></li><li><a href="#new-processes" class="table-of-contents__link toc-highlight">New Processes</a></li><li><a href="#outbound-connections" class="table-of-contents__link toc-highlight">Outbound Connections</a></li><li><a href="#socket-buffers" class="table-of-contents__link toc-highlight">Socket Buffers</a></li></ul></li><li><a href="#65-static-user-tracing" class="table-of-contents__link toc-highlight">6.5. Static User Tracing</a></li><li><a href="#66-dynamic-tracing" class="table-of-contents__link toc-highlight">6.6. Dynamic Tracing</a><ul><li><a href="#kernel-tcp_sendmsg" class="table-of-contents__link toc-highlight">Kernel: tcp_sendmsg()</a></li><li><a href="#kernel-tcp_sendmsg-with-size" class="table-of-contents__link toc-highlight">Kernel: tcp_sendmsg() with size</a></li><li><a href="#kernel-tcp_sendmsg-line-number-and-local-variable" class="table-of-contents__link toc-highlight">Kernel: tcp_sendmsg() line number and local variable</a></li><li><a href="#user-malloc" class="table-of-contents__link toc-highlight">User: malloc()</a></li><li><a href="#user-malloc-with-size" class="table-of-contents__link toc-highlight">User: malloc() with size</a></li></ul></li><li><a href="#67-scheduler-analysis" class="table-of-contents__link toc-highlight">6.7. Scheduler Analysis</a></li><li><a href="#68-ebpf" class="table-of-contents__link toc-highlight">6.8. eBPF</a><ul><li><a href="#prerequisites" class="table-of-contents__link toc-highlight">Prerequisites</a></li><li><a href="#kmem_cache_alloc-from-example" class="table-of-contents__link toc-highlight">kmem_cache_alloc from Example</a></li><li><a href="#more-examples" class="table-of-contents__link toc-highlight">More Examples</a></li></ul></li><li><a href="#7-visualizations" class="table-of-contents__link toc-highlight">7. Visualizations</a></li><li><a href="#71-flame-graphs" class="table-of-contents__link toc-highlight">7.1. Flame Graphs</a><ul><li><a href="#example" class="table-of-contents__link toc-highlight">Example</a></li><li><a href="#generation" class="table-of-contents__link toc-highlight">Generation</a></li><li><a href="#piping" class="table-of-contents__link toc-highlight">Piping</a></li><li><a href="#filtering" class="table-of-contents__link toc-highlight">Filtering</a></li><li><a href="#newer-perf" class="table-of-contents__link toc-highlight">Newer perf</a></li></ul></li><li><a href="#72-heat-maps" class="table-of-contents__link toc-highlight">7.2. Heat Maps</a><ul><li><a href="#example-1" class="table-of-contents__link toc-highlight">Example</a></li><li><a href="#gathering" class="table-of-contents__link toc-highlight">Gathering</a></li><li><a href="#processing" class="table-of-contents__link toc-highlight">Processing</a></li><li><a href="#generation-1" class="table-of-contents__link toc-highlight">Generation</a></li><li><a href="#overheads" class="table-of-contents__link toc-highlight">Overheads</a></li></ul></li><li><a href="#8-targets" class="table-of-contents__link toc-highlight">8. Targets</a></li><li><a href="#81-java" class="table-of-contents__link toc-highlight">8.1. Java</a></li><li><a href="#82-nodejs" class="table-of-contents__link toc-highlight">8.2. Node.js</a></li><li><a href="#9-more" class="table-of-contents__link toc-highlight">9. More</a></li><li><a href="#10-building" class="table-of-contents__link toc-highlight">10. Building</a><ul><li><a href="#packages-ubuntu-386" class="table-of-contents__link toc-highlight">Packages: Ubuntu, 3.8.6</a></li><li><a href="#kernel-config-386" class="table-of-contents__link toc-highlight">Kernel Config: 3.8.6</a></li></ul></li><li><a href="#101-static-builds" class="table-of-contents__link toc-highlight">10.1. Static Builds</a></li><li><a href="#11-troubleshooting" class="table-of-contents__link toc-highlight">11. Troubleshooting</a></li><li><a href="#12-other-tools" class="table-of-contents__link toc-highlight">12. Other Tools</a></li><li><a href="#13-resources" class="table-of-contents__link toc-highlight">13. Resources</a></li><li><a href="#131-posts" class="table-of-contents__link toc-highlight">13.1. Posts</a></li><li><a href="#132-links" class="table-of-contents__link toc-highlight">13.2. Links</a></li><li><a href="#14-email" class="table-of-contents__link toc-highlight">14. Email</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Fan's life, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>