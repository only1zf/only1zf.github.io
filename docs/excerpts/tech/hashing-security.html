<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-excerpts/tech/hashing-security" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Secure Salted Password Hashing - How to do it Properly | Fan&#x27;s life</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://only1zf.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://only1zf.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://only1zf.com/docs/excerpts/tech/hashing-security"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Secure Salted Password Hashing - How to do it Properly | Fan&#x27;s life"><meta data-rh="true" name="description" content="Author:"><meta data-rh="true" property="og:description" content="Author:"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="alternate" href="https://only1zf.com/docs/excerpts/tech/hashing-security" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://only1zf.com/docs/excerpts/tech/hashing-security" hreflang="x-default"><link data-rh="true" rel="canonical" href="https://crackstation.net/hashing-security.htm"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Secure Salted Password Hashing - How to do it Properly","item":"https://only1zf.com/docs/excerpts/tech/hashing-security"}]}</script><link rel="stylesheet" href="/assets/css/styles.1b12b40b.css">
<script src="/assets/js/runtime~main.d03bc2bd.js" defer="defer"></script>
<script src="/assets/js/main.21e5b53a.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Fan&#x27;s life</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/commentary">读考</a><a class="navbar__item navbar__link" href="/docs/prompts/dict">Prompts</a><a class="navbar__item navbar__link" href="/docs/chats/IaC-sec">Chats</a><a class="navbar__item navbar__link" href="/docs/guides/aws-spot-tunnel">Guides</a><a class="navbar__item navbar__link" href="/docs/refs/REST-Client">References</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/excerpts/AI/a-common-translation-prompt-for-different-languages">Excerpts</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/excerpts/AI/a-common-translation-prompt-for-different-languages"><span title="AI" class="categoryLinkLabel_W154">AI</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/excerpts/games/赛式方法论上"><span title="games" class="categoryLinkLabel_W154">games</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/excerpts/human/一个天才的陨落"><span title="human" class="categoryLinkLabel_W154">human</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/excerpts/insurance/2023年我所推荐的保险产品"><span title="insurance" class="categoryLinkLabel_W154">insurance</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/excerpts/learn/doing-well-courses"><span title="learn" class="categoryLinkLabel_W154">learn</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/excerpts/life/谈谈人生风控"><span title="life" class="categoryLinkLabel_W154">life</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/excerpts/management/华为基本法"><span title="management" class="categoryLinkLabel_W154">management</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/excerpts/money/2021不烦恼指南"><span title="money" class="categoryLinkLabel_W154">money</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/docs/excerpts/tech/a-successful-git-branching-model"><span title="tech" class="categoryLinkLabel_W154">tech</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/excerpts/tech/a-successful-git-branching-model"><span title="A successful Git branching model" class="linkLabel_WmDU">A successful Git branching model</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/excerpts/tech/dice"><span title="EFF Dice-Generated Passphrases" class="linkLabel_WmDU">EFF Dice-Generated Passphrases</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/excerpts/tech/hashing-security"><span title="Secure Salted Password Hashing - How to do it Properly" class="linkLabel_WmDU">Secure Salted Password Hashing - How to do it Properly</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/excerpts/tech/startup-ideas"><span title="How to Get Startup Ideas" class="linkLabel_WmDU">How to Get Startup Ideas</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/excerpts/tech/漫谈各种黑科技式 DNS 技术在代理环境中的应用"><span title="漫谈各种黑科技式 DNS 技术在代理环境中的应用" class="linkLabel_WmDU">漫谈各种黑科技式 DNS 技术在代理环境中的应用</span></a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/excerpts/苟活的中年人"><span title="苟活的中年人" class="linkLabel_WmDU">苟活的中年人</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/excerpts/血尿酸高和痛风的人吃不得豆腐可以喝白酒"><span title="血尿酸高和痛风的人吃不得豆腐可以喝白酒？华西营养专家说，信你就拐了！" class="linkLabel_WmDU">血尿酸高和痛风的人吃不得豆腐可以喝白酒？华西营养专家说，信你就拐了！</span></a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">tech</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Secure Salted Password Hashing - How to do it Properly</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Secure Salted Password Hashing - How to do it Properly</h1></header>
<p><strong>Author:</strong></p>
<p><strong>Original link:</strong> <a href="https://crackstation.net/hashing-security.htm" target="_blank" rel="noopener noreferrer" class="">https://crackstation.net/hashing-security.htm</a></p>
<p><strong>Note:</strong> All rights belong to the original author. This post includes brief excerpts for commentary and review. Please read the full article at the source.</p>
<p><strong>Published</strong> on 2021-9-28</p>
<hr>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="salted-password-hashing---doing-it-right">Salted Password Hashing - Doing it Right<a href="#salted-password-hashing---doing-it-right" class="hash-link" aria-label="Salted Password Hashing - Doing it Right的直接链接" title="Salted Password Hashing - Doing it Right的直接链接" translate="no">​</a></h2>
<p>If you&#x27;re a web developer, you&#x27;ve probably had to make a user account system. The most important aspect of a user account system is how user passwords are protected. User account databases are hacked frequently, so you absolutely must do something to protect your users&#x27; passwords if your website is ever breached. The best way to protect passwords is to employ <strong>salted password hashing</strong>. This page will explain why it&#x27;s done the way it is.</p>
<p>There are a lot of conflicting ideas and misconceptions on how to do password hashing properly, probably due to the abundance of misinformation on the web. Password hashing is one of those things that&#x27;s so simple, but yet so many people get wrong. With this page, I hope to explain not only the correct way to do it, but why it should be done that way.</p>
<p><strong>IMPORTANT WARNING:</strong> If you are thinking of writing your own password hashing code, <strong>please don&#x27;t!</strong>. It&#x27;s too easy to screw up. No, that cryptography course you took in university doesn&#x27;t make you exempt from this warning. This applies to everyone: <strong>DO NOT WRITE YOUR OWN CRYPTO!</strong> The problem of storing passwords has already been solved. Use either use either <a href="http://www.openwall.com/phpass/" target="_blank" rel="noopener noreferrer" class="">phpass</a>, the PHP, C#, Java, and Ruby implementations in <a href="https://github.com/defuse/password-hashing" target="_blank" rel="noopener noreferrer" class="">defuse/password-hashing</a>, or <a href="https://download.libsodium.org/doc/password_hashing/index.html" target="_blank" rel="noopener noreferrer" class="">libsodium</a>.</p>
<p>If for some reason you missed that big red warning note, please go read it now. Really, this guide is <strong>not</strong> meant to walk you through the process of writing your own storage system, it&#x27;s to explain the reasons why passwords should be stored a certain way.</p>
<p>You may use the following links to jump to the different sections of this page.</p>
<table><thead><tr><th><a href="https://crackstation.net/#normalhashing" target="_blank" rel="noopener noreferrer" title="What are hash functions and why are they used?" class="">1. What is password hashing?</a></th><th><a href="https://crackstation.net/#attacks" target="_blank" rel="noopener noreferrer" title="Methods for making hash cracking more efficient" class="">2. How Hashes are Cracked</a></th><th><a href="https://crackstation.net/#salt" target="_blank" rel="noopener noreferrer" title="Adding salt to render hash cracking attacks less effective" class="">3. Adding Salt</a></th></tr></thead><tbody><tr><td><a href="https://crackstation.net/#ineffective" target="_blank" rel="noopener noreferrer" title="The wrong way to do password hashing" class="">4. Ineffective Hashing Methods</a></td><td><a href="https://crackstation.net/#properhashing" target="_blank" rel="noopener noreferrer" title="The right way to do password hashing, with salt" class="">5. How to hash properly</a></td><td><a href="https://crackstation.net/#faq" target="_blank" rel="noopener noreferrer" title="Frequently asked questions about password hashing and salt" class="">6. Frequently Asked Questions</a></td></tr></tbody></table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-is-password-hashing">What is password hashing?<a href="#what-is-password-hashing" class="hash-link" aria-label="What is password hashing?的直接链接" title="What is password hashing?的直接链接" translate="no">​</a></h2>
<p>hash(&quot;hello&quot;) = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824<br>
<!-- -->hash(&quot;hbllo&quot;) = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366<br>
<!-- -->hash(&quot;waltz&quot;) = c0e81794384491161f1777c232bc6bd9ec38f616560b120fda8e90f383853542</p>
<p>Hash algorithms are one way functions. They turn any amount of data into a fixed-length &quot;fingerprint&quot; that cannot be reversed. They also have the property that if the input changes by even a tiny bit, the resulting hash is completely different (see the example above). This is great for protecting passwords, because we want to store passwords in a form that protects them even if the password file itself is compromised, but at the same time, we need to be able to verify that a user&#x27;s password is correct.</p>
<p>The general workflow for account registration and authentication in a hash-based account system is as follows:</p>
<ol>
<li class="">The user creates an account.</li>
<li class="">Their password is hashed and stored in the database. At no point is the plain-text (unencrypted) password ever written to the hard drive.</li>
<li class="">When the user attempts to login, the hash of the password they entered is checked against the hash of their real password (retrieved from the database).</li>
<li class="">If the hashes match, the user is granted access. If not, the user is told they entered invalid login credentials.</li>
<li class="">Steps 3 and 4 repeat every time someone tries to login to their account.</li>
</ol>
<p>In step 4, never tell the user if it was the username or password they got wrong. Always display a generic message like &quot;Invalid username or password.&quot; This prevents attackers from enumerating valid usernames without knowing their passwords.</p>
<p>It should be noted that the hash functions used to protect passwords are not the same as the hash functions you may have seen in a data structures course. The hash functions used to implement data structures such as hash tables are designed to be fast, not secure. Only <strong>cryptographic hash functions</strong> may be used to implement password hashing. Hash functions like SHA256, SHA512, RipeMD, and WHIRLPOOL are cryptographic hash functions.</p>
<p>It is easy to think that all you have to do is run the password through a cryptographic hash function and your users&#x27; passwords will be secure. This is far from the truth. There are many ways to recover passwords from plain hashes very quickly. There are several easy-to-implement techniques that make these &quot;attacks&quot; much less effective. To motivate the need for these techniques, consider this very website. On the front page, you can submit a list of hashes to be cracked, and receive results in less than a second. Clearly, simply hashing the password does not meet our needs for security.</p>
<p>The next section will discuss some of the common attacks used to crack plain password hashes.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="how-hashes-are-cracked">How Hashes are Cracked<a href="#how-hashes-are-cracked" class="hash-link" aria-label="How Hashes are Cracked的直接链接" title="How Hashes are Cracked的直接链接" translate="no">​</a></h2>
<ul>
<li class="">
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="dictionary-and-brute-force-attacks">Dictionary and Brute Force Attacks<a href="#dictionary-and-brute-force-attacks" class="hash-link" aria-label="Dictionary and Brute Force Attacks的直接链接" title="Dictionary and Brute Force Attacks的直接链接" translate="no">​</a></h3>
<table><thead><tr><th>Dictionary Attack Trying apple: failed Trying blueberry: failed Trying justinbeiber: failed ... Trying letmein: failed Trying s3cr3t: success!</th><th>Brute Force Attack Trying aaaa: failed Trying aaab: failed Trying aaac: failed ... Trying acdb: failed Trying acdc: success!</th></tr></thead><tbody><tr><td>The simplest way to crack a hash is to try to guess the password, hashing each guess, and checking if the guess&#x27;s hash equals the hash being cracked. If the hashes are equal, the guess is the password. The two most common ways of guessing passwords are <strong>dictionary attacks</strong> and <strong>brute-force attacks</strong>.</td><td></td></tr><tr><td>A dictionary attack uses a file containing words, phrases, common passwords, and other strings that are likely to be used as a password. Each word in the file is hashed, and its hash is compared to the password hash. If they match, that word is the password. These dictionary files are constructed by extracting words from large bodies of text, and even from real databases of passwords. Further processing is often applied to dictionary files, such as replacing words with their &quot;leet speak&quot; equivalents (&quot;hello&quot; becomes &quot;h3110&quot;), to make them more effective.</td><td></td></tr><tr><td>A brute-force attack tries every possible combination of characters up to a given length. These attacks are very computationally expensive, and are usually the least efficient in terms of hashes cracked per processor time, but they will always eventually find the password. Passwords should be long enough that searching through all possible character strings to find it will take too long to be worthwhile.</td><td></td></tr><tr><td>There is no way to prevent dictionary attacks or brute force attacks. They can be made less effective, but there isn&#x27;t a way to prevent them altogether. If your password hashing system is secure, the only way to crack the hashes will be to run a dictionary or brute-force attack on each hash.</td><td></td></tr></tbody></table>
</li>
<li class="">
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lookup-tables">Lookup Tables<a href="#lookup-tables" class="hash-link" aria-label="Lookup Tables的直接链接" title="Lookup Tables的直接链接" translate="no">​</a></h3>
<!-- -->Searching: 5f4dcc3b5aa765d61d8327deb882cf99: FOUND: password5<br>
<!-- -->Searching: 6cbe615c106f422d23669b610b564800: not in database<br>
<!-- -->Searching: 630bf032efe4507f2c57b280995925a9: FOUND: letMEin12<br>
<!-- -->Searching: 386f43fab5d096a7a66d67c8f213e5ec: FOUND: mcd0nalds<br>
<!-- -->Searching: d5ec75d5fe70d428685510fae36492d9: FOUND: p@ssw0rd!<br>
<!-- -->Lookup tables are an extremely effective method for cracking many hashes of the same type very quickly. The general idea is to <strong>pre-compute</strong> the hashes of the passwords in a password dictionary and store them, and their corresponding password, in a lookup table data structure. A good implementation of a lookup table can process hundreds of hash lookups per second, even when they contain many billions of hashes.
If you want a better idea of how fast lookup tables can be, try cracking the following sha256 hashes with CrackStation&#x27;s <a href="https://crackstation.net/" target="_blank" rel="noopener noreferrer" class="">free hash cracker</a>.
c11083b4b0a7743af748c85d343dfee9fbb8b2576c05f3a7f0d632b0926aadfc<br>
<!-- -->08eac03b80adc33dc7d8fbe44b7c7b05d3a2c511166bdb43fcb710b03ba919e7<br>
<!-- -->e4ba5cbd251c98e6cd1c23f126a3b81d8d8328abc95387229850952b3ef9f904<br>
<!-- -->5206b8b8a996cf5320cb12ca91c7b790fba9f030408efe83ebb83548dc3007bd</li>
<li class="">
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="reverse-lookup-tables">Reverse Lookup Tables<a href="#reverse-lookup-tables" class="hash-link" aria-label="Reverse Lookup Tables的直接链接" title="Reverse Lookup Tables的直接链接" translate="no">​</a></h3>
<!-- -->Searching for hash(apple) in users&#x27; hash list...: Matches [alice3, 0bob0, charles8]<br>
<!-- -->Searching for hash(blueberry) in users&#x27; hash list...: Matches [usr10101, timmy, john91]<br>
<!-- -->Searching for hash(letmein) in users&#x27; hash list...: Matches [wilson10, dragonslayerX, joe1984]<br>
<!-- -->Searching for hash(s3cr3t) in users&#x27; hash list...: Matches [bruce19, knuth1337, john87]<br>
<!-- -->Searching for hash(z@29hjja) in users&#x27; hash list...: No users used this password<br>
<!-- -->This attack allows an attacker to apply a dictionary or brute-force attack to many hashes at the same time, without having to pre-compute a lookup table.
First, the attacker creates a lookup table that maps each password hash from the compromised user account database to a list of users who had that hash. The attacker then hashes each password guess and uses the lookup table to get a list of users whose password was the attacker&#x27;s guess. This attack is especially effective because it is common for many users to have the same password.</li>
<li class="">
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="rainbow-tables">Rainbow Tables<a href="#rainbow-tables" class="hash-link" aria-label="Rainbow Tables的直接链接" title="Rainbow Tables的直接链接" translate="no">​</a></h3>
<!-- -->Rainbow tables are a time-memory trade-off technique. They are like lookup tables, except that they sacrifice hash cracking speed to make the lookup tables smaller. Because they are smaller, the solutions to more hashes can be stored in the same amount of space, making them more effective. Rainbow tables that can crack any md5 hash of a password up to 8 characters long <a href="http://www.freerainbowtables.com/en/tables2/" target="_blank" rel="noopener noreferrer" class="">exist</a>.</li>
</ul>
<p>Next, we&#x27;ll look at a technique called salting, which makes it impossible to use lookup tables and rainbow tables to crack a hash.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="adding-salt">Adding Salt<a href="#adding-salt" class="hash-link" aria-label="Adding Salt的直接链接" title="Adding Salt的直接链接" translate="no">​</a></h2>
<p>hash(&quot;hello&quot;) = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824<br>
<!-- -->hash(&quot;hello&quot; + &quot;QxLUF1bgIAdeQX&quot;) = 9e209040c863f84a31e719795b2577523954739fe5ed3b58a75cff2127075ed1<br>
<!-- -->hash(&quot;hello&quot; + &quot;bv5PehSMfV11Cd&quot;) = d1d3ec2e6f20fd420d50e2642992841d8338a314b8ea157c9e18477aaef226ab<br>
<!-- -->hash(&quot;hello&quot; + &quot;YYLmfY6IehjZMQ&quot;) = a49670c3c18b9e079b9cfaf51634f563dc8ae3070db2c4a8544305df1b60f007</p>
<p>Lookup tables and rainbow tables only work because each password is hashed the exact same way. If two users have the same password, they&#x27;ll have the same password hashes. We can prevent these attacks by randomizing each hash, so that when the same password is hashed twice, the hashes are not the same.</p>
<p>We can randomize the hashes by appending or prepending a random string, called a <strong>salt</strong>, to the password before hashing. As shown in the example above, this makes the same password hash into a completely different string every time. To check if a password is correct, we need the salt, so it is usually stored in the user account database along with the hash, or as part of the hash string itself.</p>
<p>The salt does not need to be secret. Just by randomizing the hashes, lookup tables, reverse lookup tables, and rainbow tables become ineffective. An attacker won&#x27;t know in advance what the salt will be, so they can&#x27;t pre-compute a lookup table or rainbow table. If each user&#x27;s password is hashed with a different salt, the reverse lookup table attack won&#x27;t work either.</p>
<p>In the next section, we&#x27;ll look at how salt is commonly implemented incorrectly.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-wrong-way-short-salt--salt-reuse">The WRONG Way: Short Salt &amp; Salt Reuse<a href="#the-wrong-way-short-salt--salt-reuse" class="hash-link" aria-label="The WRONG Way: Short Salt &amp; Salt Reuse的直接链接" title="The WRONG Way: Short Salt &amp; Salt Reuse的直接链接" translate="no">​</a></h2>
<p>The most common salt implementation errors are reusing the same salt in multiple hashes, or using a salt that is too short.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="salt-reuse">Salt Reuse<a href="#salt-reuse" class="hash-link" aria-label="Salt Reuse的直接链接" title="Salt Reuse的直接链接" translate="no">​</a></h3>
<p>A common mistake is to use the same salt in each hash. Either the salt is hard-coded into the program, or is generated randomly once. This is ineffective because if two users have the same password, they&#x27;ll still have the same hash. An attacker can still use a reverse lookup table attack to run a dictionary attack on every hash at the same time. They just have to apply the salt to each password guess before they hash it. If the salt is hard-coded into a popular product, lookup tables and rainbow tables can be built for that salt, to make it easier to crack hashes generated by the product.</p>
<p>A new random salt must be generated each time a user creates an account or changes their password.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="short-salt">Short Salt<a href="#short-salt" class="hash-link" aria-label="Short Salt的直接链接" title="Short Salt的直接链接" translate="no">​</a></h3>
<p>If the salt is too short, an attacker can build a lookup table for every possible salt. For example, if the salt is only three ASCII characters, there are only 95x95x95 = 857,375 possible salts. That may seem like a lot, but if each lookup table contains only 1MB of the most common passwords, collectively they will be only 837GB, which is not a lot considering 1000GB hard drives can be bought for under $100 today.</p>
<p>For the same reason, the username shouldn&#x27;t be used as a salt. Usernames may be unique to a single service, but they are predictable and often reused for accounts on other services. An attacker can build lookup tables for common usernames and use them to crack username-salted hashes.</p>
<p>To make it impossible for an attacker to create a lookup table for every possible salt, the salt must be long. A good rule of thumb is to use a salt that is the same size as the output of the hash function. For example, the output of SHA256 is 256 bits (32 bytes), so the salt should be at least 32 random bytes.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-wrong-way-double-hashing--wacky-hash-functions">The WRONG Way: Double Hashing &amp; Wacky Hash Functions<a href="#the-wrong-way-double-hashing--wacky-hash-functions" class="hash-link" aria-label="The WRONG Way: Double Hashing &amp; Wacky Hash Functions的直接链接" title="The WRONG Way: Double Hashing &amp; Wacky Hash Functions的直接链接" translate="no">​</a></h2>
<p>This section covers another common password hashing misconception: wacky combinations of hash algorithms. It&#x27;s easy to get carried away and try to combine different hash functions, hoping that the result will be more secure. In practice, though, there is very little benefit to doing it. All it does is create interoperability problems, and can sometimes even make the hashes less secure. Never try to invent your own crypto, always use a standard that has been designed by experts. Some will argue that using multiple hash functions makes the process of computing the hash slower, so cracking is slower, but there&#x27;s a better way to make the cracking process slower as we&#x27;ll see later.</p>
<p>Here are some examples of poor wacky hash functions I&#x27;ve seen suggested in forums on the internet.</p>
<ul>
<li class="">md5(sha1(password))</li>
<li class="">md5(md5(salt) + md5(password))</li>
<li class="">sha1(sha1(password))</li>
<li class="">sha1(str_rot13(password + salt))</li>
<li class="">md5(sha1(md5(md5(password) + sha1(password)) + md5(password)))</li>
</ul>
<p>Do not use any of these.</p>
<p>Note: This section has proven to be controversial. I&#x27;ve received a number of emails arguing that wacky hash functions are a good thing, because it&#x27;s better if the attacker doesn&#x27;t know which hash function is in use, it&#x27;s less likely for an attacker to have pre-computed a rainbow table for the wacky hash function, and it takes longer to compute the hash function.</p>
<p>An attacker cannot attack a hash when he doesn&#x27;t know the algorithm, but note <a href="https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle" target="_blank" rel="noopener noreferrer" class="">Kerckhoffs&#x27;s principle</a>, that the attacker will usually have access to the source code (especially if it&#x27;s free or open source software), and that given a few password-hash pairs from the target system, it is not difficult to reverse engineer the algorithm. It does take longer to compute wacky hash functions, but only by a small constant factor. It&#x27;s better to use an iterated algorithm that&#x27;s designed to be extremely hard to parallelize (these are discussed below). And, properly salting the hash solves the rainbow table problem.</p>
<p>If you really want to use a standardized &quot;wacky&quot; hash function like HMAC, then it&#x27;s OK. But if your reason for doing so is to make the hash computation slower, read the section below about key stretching first.</p>
<p>Compare these minor benefits to the risks of accidentally implementing a completely insecure hash function and the interoperability problems wacky hashes create. It&#x27;s clearly best to use a standard and well-tested algorithm.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="hash-collisions">Hash Collisions<a href="#hash-collisions" class="hash-link" aria-label="Hash Collisions的直接链接" title="Hash Collisions的直接链接" translate="no">​</a></h2>
<p>Because hash functions map arbitrary amounts of data to fixed-length strings, there must be some inputs that hash into the same string. Cryptographic hash functions are designed to make these collisions incredibly difficult to find. From time to time, cryptographers find &quot;attacks&quot; on hash functions that make finding collisions easier. A recent example is the MD5 hash function, for which collisions have actually been found.</p>
<p>Collision attacks are a sign that it may be more likely for a string other than the user&#x27;s password to have the same hash. However, finding collisions in even a weak hash function like MD5 requires a lot of dedicated computing power, so it is very unlikely that these collisions will happen &quot;by accident&quot; in practice. A password hashed using MD5 and salt is, for all practical purposes, just as secure as if it were hashed with SHA256 and salt. Nevertheless, it is a good idea to use a more secure hash function like SHA256, SHA512, RipeMD, or WHIRLPOOL if possible.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-right-way-how-to-hash-properly">The RIGHT Way: How to Hash Properly<a href="#the-right-way-how-to-hash-properly" class="hash-link" aria-label="The RIGHT Way: How to Hash Properly的直接链接" title="The RIGHT Way: How to Hash Properly的直接链接" translate="no">​</a></h2>
<p>This section describes exactly how passwords should be hashed. The first subsection covers the basics—everything that is absolutely necessary. The following subsections explain how the basics can be augmented to make the hashes even harder to crack.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-basics-hashing-with-salt">The Basics: Hashing with Salt<a href="#the-basics-hashing-with-salt" class="hash-link" aria-label="The Basics: Hashing with Salt的直接链接" title="The Basics: Hashing with Salt的直接链接" translate="no">​</a></h3>
<p><strong>Warning: Do not just read this section. You absolutely must implement the stuff in the next section: &quot;Making Password Cracking Harder: Slow Hash Functions&quot;.</strong></p>
<p>We&#x27;ve seen how malicious hackers can crack plain hashes very quickly using lookup tables and rainbow tables. We&#x27;ve learned that randomizing the hashing using salt is the solution to the problem. But how do we generate the salt, and how do we apply it to the password?</p>
<p>Salt should be generated using a <strong>Cryptographically Secure Pseudo-Random Number Generator</strong> (CSPRNG). CSPRNGs are very different than ordinary pseudo-random number generators, like the &quot;C&quot; language&#x27;s rand() function. As the name suggests, CSPRNGs are designed to be cryptographically secure, meaning they provide a high level of randomness and are completely unpredictable. We don&#x27;t want our salts to be predictable, so we must use a CSPRNG. The following table lists some CSPRNGs that exist for some popular programming platforms.</p>
<table><thead><tr><th>Platform</th><th>CSPRNG</th></tr></thead><tbody><tr><td>PHP</td><td><a href="http://php.net/manual/en/function.mcrypt-create-iv.php" target="_blank" rel="noopener noreferrer" class="">mcrypt_create_iv</a>, <a href="http://php.net/manual/en/function.openssl-random-pseudo-bytes.php" target="_blank" rel="noopener noreferrer" class="">openssl_random_pseudo_bytes</a></td></tr><tr><td>Java</td><td><a href="http://docs.oracle.com/javase/6/docs/api/java/security/SecureRandom.html" target="_blank" rel="noopener noreferrer" class="">java.security.SecureRandom</a></td></tr><tr><td>Dot NET (C#, VB)</td><td><a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.aspx" target="_blank" rel="noopener noreferrer" class="">System.Security.Cryptography.RNGCryptoServiceProvider</a></td></tr><tr><td>Ruby</td><td><a href="http://rubydoc.info/stdlib/securerandom/1.9.3/SecureRandom" target="_blank" rel="noopener noreferrer" class="">SecureRandom</a></td></tr><tr><td>Python</td><td><a href="https://docs.python.org/3/library/secrets.html" target="_blank" rel="noopener noreferrer" class="">secrets</a></td></tr><tr><td>Perl</td><td><a href="http://search.cpan.org/~mkanat/Math-Random-Secure-0.06/lib/Math/Random/Secure.pm" target="_blank" rel="noopener noreferrer" class="">Math::Random::Secure</a></td></tr><tr><td>C/C++ (Windows API)</td><td><a href="http://en.wikipedia.org/wiki/CryptGenRandom" target="_blank" rel="noopener noreferrer" class="">CryptGenRandom</a></td></tr><tr><td>Any language on GNU/Linux or Unix</td><td>Read from <a href="http://en.wikipedia.org/wiki//dev/random" target="_blank" rel="noopener noreferrer" class="">/dev/random</a> or /dev/urandom</td></tr></tbody></table>
<p>The salt needs to be unique per-user per-password. Every time a user creates an account or changes their password, the password should be hashed using a new random salt. Never reuse a salt. The salt also needs to be long, so that there are many possible salts. As a rule of thumb, make your salt is at least as long as the hash function&#x27;s output. The salt should be stored in the user account table alongside the hash.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="to-store-a-password">To Store a Password<a href="#to-store-a-password" class="hash-link" aria-label="To Store a Password的直接链接" title="To Store a Password的直接链接" translate="no">​</a></h4>
<ol>
<li class="">Generate a long random salt using a CSPRNG.</li>
<li class="">Prepend the salt to the password and hash it with a <strong>standard</strong> password hashing function like Argon2, bcrypt, scrypt, or PBKDF2.</li>
<li class="">Save both the salt and the hash in the user&#x27;s database record.</li>
</ol>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="to-validate-a-password">To Validate a Password<a href="#to-validate-a-password" class="hash-link" aria-label="To Validate a Password的直接链接" title="To Validate a Password的直接链接" translate="no">​</a></h4>
<ol>
<li class="">Retrieve the user&#x27;s salt and hash from the database.</li>
<li class="">Prepend the salt to the given password and hash it using the same hash function.</li>
<li class="">Compare the hash of the given password with the hash from the database. If they match, the password is correct. Otherwise, the password is incorrect.</li>
</ol>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="in-a-web-application-always-hash-on-the-server">In a Web Application, always hash on the server<a href="#in-a-web-application-always-hash-on-the-server" class="hash-link" aria-label="In a Web Application, always hash on the server的直接链接" title="In a Web Application, always hash on the server的直接链接" translate="no">​</a></h4>
<p>If you are writing a web application, you might wonder <em>where</em> to hash. Should the password be hashed in the user&#x27;s browser with JavaScript, or should it be sent to the server &quot;in the clear&quot; and hashed there?</p>
<p>Even if you are hashing the user&#x27;s passwords in JavaScript, you still have to hash the hashes on the server. Consider a website that hashes users&#x27; passwords in the user&#x27;s browser without hashing the hashes on the server. To authenticate a user, this website will accept a hash from the browser and check if that hash exactly matches the one in the database. This seems more secure than just hashing on the server, since the users&#x27; passwords are never sent to the server, but it&#x27;s not.</p>
<p>The problem is that the client-side hash logically <em>becomes</em> the user&#x27;s password. All the user needs to do to authenticate is tell the server the hash of their password. If a bad guy got a user&#x27;s <em>hash</em> they could use it to authenticate to the server, without knowing the user&#x27;s password! So, if the bad guy somehow steals the database of hashes from this hypothetical website, they&#x27;ll have immediate access to everyone&#x27;s accounts without having to guess any passwords.</p>
<p>This isn&#x27;t to say that you <em>shouldn&#x27;t</em> hash in the browser, but if you do, you absolutely have to hash on the server too. Hashing in the browser is certainly a good idea, but consider the following points for your implementation:</p>
<ul>
<li class="">Client-side password hashing is <strong>not</strong> a substitute for HTTPS (SSL/TLS). If the connection between the browser and the server is insecure, a man-in-the-middle can modify the JavaScript code as it is downloaded to remove the hashing functionality and get the user&#x27;s password.</li>
<li class="">Some web browsers don&#x27;t support JavaScript, and some users disable JavaScript in their browser. So for maximum compatibility, your app should detect whether or not the browser supports JavaScript and emulate the client-side hash on the server if it doesn&#x27;t.</li>
<li class="">You need to salt the client-side hashes too. The obvious solution is to make the client-side script ask the server for the user&#x27;s salt. Don&#x27;t do that, because it lets the bad guys check if a username is valid without knowing the password. Since you&#x27;re hashing and salting (with a good salt) on the server too, it&#x27;s OK to use the username (or email) concatenated with a site-specific string (e.g. domain name) as the client-side salt.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="making-password-cracking-harder-slow-hash-functions">Making Password Cracking Harder: Slow Hash Functions<a href="#making-password-cracking-harder-slow-hash-functions" class="hash-link" aria-label="Making Password Cracking Harder: Slow Hash Functions的直接链接" title="Making Password Cracking Harder: Slow Hash Functions的直接链接" translate="no">​</a></h3>
<p>Salt ensures that attackers can&#x27;t use specialized attacks like lookup tables and rainbow tables to crack large collections of hashes quickly, but it doesn&#x27;t prevent them from running dictionary or brute-force attacks on each hash individually. High-end graphics cards (GPUs) and custom hardware can compute billions of hashes per second, so these attacks are still very effective. To make these attacks less effective, we can use a technique known as <strong>key stretching</strong>.</p>
<p>The idea is to make the hash function very slow, so that even with a fast GPU or custom hardware, dictionary and brute-force attacks are too slow to be worthwhile. The goal is to make the hash function slow enough to impede attacks, but still fast enough to not cause a noticeable delay for the user.</p>
<p>Key stretching is implemented using a special type of CPU-intensive hash function. Don&#x27;t try to invent your own–simply iteratively hashing the hash of the password isn&#x27;t enough as it can be parallelized in hardware and executed as fast as a normal hash. Use a standard algorithm like <a href="http://en.wikipedia.org/wiki/PBKDF2" target="_blank" rel="noopener noreferrer" class="">PBKDF2</a> or <a href="http://en.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener noreferrer" class="">bcrypt</a>. You can find a PHP implementation of <a href="https://defuse.ca/php-pbkdf2.htm" target="_blank" rel="noopener noreferrer" class="">PBKDF2 here</a>.</p>
<p>These algorithms take a security factor or iteration count as an argument. This value determines how slow the hash function will be. For desktop software or smartphone apps, the best way to choose this parameter is to run a short benchmark on the device to find the value that makes the hash take about half a second. This way, your program can be as secure as possible without affecting the user experience.</p>
<p>If you use a key stretching hash in a web application, be aware that you will need extra computational resources to process large volumes of authentication requests, and that key stretching may make it easier to run a Denial of Service (DoS) attack on your website. I still recommend using key stretching, but with a lower iteration count. You should calculate the iteration count based on your computational resources and the expected maximum authentication request rate. The denial of service threat can be eliminated by making the user solve a CAPTCHA every time they log in. Always design your system so that the iteration count can be increased or decreased in the future.</p>
<p>If you are worried about the computational burden, but still want to use key stretching in a web application, consider running the key stretching algorithm in the user&#x27;s browser with JavaScript. The <a href="http://crypto.stanford.edu/sjcl/" target="_blank" rel="noopener noreferrer" class="">Stanford JavaScript Crypto Library</a> includes PBKDF2. The iteration count should be set low enough that the system is usable with slower clients like mobile devices, and the system should fall back to server-side computation if the user&#x27;s browser doesn&#x27;t support JavaScript. Client-side key stretching does not remove the need for server-side hashing. You must hash the hash generated by the client the same way you would hash a normal password.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="impossible-to-crack-hashes-keyed-hashes-and-password-hashing-hardware">Impossible-to-crack Hashes: Keyed Hashes and Password Hashing Hardware<a href="#impossible-to-crack-hashes-keyed-hashes-and-password-hashing-hardware" class="hash-link" aria-label="Impossible-to-crack Hashes: Keyed Hashes and Password Hashing Hardware的直接链接" title="Impossible-to-crack Hashes: Keyed Hashes and Password Hashing Hardware的直接链接" translate="no">​</a></h3>
<p>As long as an attacker can use a hash to check whether a password guess is right or wrong, they can run a dictionary or brute-force attack on the hash. The next step is to add a <strong>secret key</strong> to the hash so that only someone who knows the key can use the hash to validate a password. This can be accomplished two ways. Either the hash can be encrypted using a cipher like AES, or the secret key can be included in the hash using a keyed hash algorithm like <a href="http://en.wikipedia.org/wiki/HMAC" target="_blank" rel="noopener noreferrer" class="">HMAC</a>.</p>
<p>This is not as easy as it sounds. The key has to be kept secret from an attacker even in the event of a breach. If an attacker gains full access to the system, they&#x27;ll be able to steal the key no matter where it is stored. The key must be stored in an external system, such as a physically separate server dedicated to password validation, or a special hardware device attached to the server such as the <a href="https://www.yubico.com/YubiHSM" target="_blank" rel="noopener noreferrer" class="">YubiHSM</a>.</p>
<p>I highly recommend this approach for any large scale (more than 100,000 users) service. I consider it necessary for any service hosting more than 1,000,000 user accounts.</p>
<p>If you can&#x27;t afford multiple dedicated servers or special hardware devices, you can still get some of the benefits of keyed hashes on a standard web server. Most databases are breached using <a href="http://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="noopener noreferrer" class="">SQL Injection Attacks</a>, which, in most cases, don&#x27;t give attackers access to the local filesystem (disable local filesystem access in your SQL server if it has this feature). If you generate a random key and store it in a file that isn&#x27;t accessible from the web, and include it into the salted hashes, then the hashes won&#x27;t be vulnerable if your database is breached using a simple SQL injection attack. Don&#x27;t hard-code a key into the source code, generate it randomly when the application is installed. This isn&#x27;t as secure as using a separate system to do the password hashing, because if there are SQL injection vulnerabilities in a web application, there are probably other types, such as Local File Inclusion, that an attacker could use to read the secret key file. But, it&#x27;s better than nothing.</p>
<p>Please note that keyed hashes do not remove the need for salt. Clever attackers will eventually find ways to compromise the keys, so it is important that hashes are still protected by salt and key stretching.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="other-security-measures">Other Security Measures<a href="#other-security-measures" class="hash-link" aria-label="Other Security Measures的直接链接" title="Other Security Measures的直接链接" translate="no">​</a></h2>
<p>Password hashing protects passwords in the event of a security breach. It does not make the application as a whole more secure. Much more must be done to prevent the password hashes (and other user data) from being stolen in the first place.</p>
<p>Even experienced developers must be educated in security in order to write secure applications. A great resource for learning about web application vulnerabilities is <a href="https://www.owasp.org/index.php/Main_Page" target="_blank" rel="noopener noreferrer" class="">The Open Web Application Security Project (OWASP)</a>. A good introduction is the <a href="https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf" target="_blank" rel="noopener noreferrer" class="">OWASP Top Ten Vulnerability List</a>. Unless you understand all the vulnerabilities on the list, do not attempt to write a web application that deals with sensitive data. It is the employer&#x27;s responsibility to ensure all developers are adequately trained in secure application development.</p>
<p>Having a third party &quot;penetration test&quot; your application is a good idea. Even the best programmers make mistakes, so it always makes sense to have a security expert review the code for potential vulnerabilities. Find a trustworthy organization (or hire staff) to review your code on a regular basis. The security review process should begin early in an application&#x27;s life and continue throughout its development.</p>
<p>It is also important to monitor your website to detect a breach if one does occur. I recommend hiring at least one person whose full time job is detecting and responding to security breaches. If a breach goes undetected, the attacker can make your website infect visitors with malware, so it is extremely important that breaches are detected and responded to promptly.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="frequently-asked-questions">Frequently Asked Questions<a href="#frequently-asked-questions" class="hash-link" aria-label="Frequently Asked Questions的直接链接" title="Frequently Asked Questions的直接链接" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-hash-algorithm-should-i-use">What hash algorithm should I use?<a href="#what-hash-algorithm-should-i-use" class="hash-link" aria-label="What hash algorithm should I use?的直接链接" title="What hash algorithm should I use?的直接链接" translate="no">​</a></h3>
<p><strong>DO</strong> use:</p>
<ul>
<li class="">Well-designed key stretching algorithms such as <a href="http://en.wikipedia.org/wiki/PBKDF2" target="_blank" rel="noopener noreferrer" class="">PBKDF2</a>, <a href="http://en.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener noreferrer" class="">bcrypt</a>, and <a href="http://www.tarsnap.com/scrypt.html" target="_blank" rel="noopener noreferrer" class="">scrypt</a>.</li>
<li class="">OpenWall&#x27;s <a href="http://www.openwall.com/phpass/" target="_blank" rel="noopener noreferrer" class="">Portable PHP password hashing framework</a></li>
<li class=""><a href="https://github.com/defuse/password-hashing" target="_blank" rel="noopener noreferrer" class="">My implementations of PBKDF2 in PHP, C#, Java, and Ruby.</a></li>
<li class="">Secure versions of <a href="http://en.wikipedia.org/wiki/Crypt_(Unix)#Library_Function_crypt.283.29" target="_blank" rel="noopener noreferrer" class="">crypt</a> ($2y$, $5$, $6$)</li>
</ul>
<p><strong>DO NOT</strong> use:</p>
<ul>
<li class="">Fast cryptographic hash functions such as MD5, SHA1, SHA256, SHA512, RipeMD, WHIRLPOOL, SHA3, etc.</li>
<li class="">Insecure versions of crypt ($1$, $2$, $2x$, $3$).</li>
<li class="">Any algorithm that you designed yourself. Only use technology that is in the public domain and has been well-tested by experienced cryptographers.</li>
</ul>
<p>Even though there are no cryptographic attacks on MD5 or SHA1 that make their hashes easier to crack, they are old and are widely considered (somewhat incorrectly) to be inadequate for password storage. So I don&#x27;t recommend using them. An exception to this rule is PBKDF2, which is frequently implemented using SHA1 as the underlying hash function.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="how-should-i-allow-users-to-reset-their-password-when-they-forget-it">How should I allow users to reset their password when they forget it?<a href="#how-should-i-allow-users-to-reset-their-password-when-they-forget-it" class="hash-link" aria-label="How should I allow users to reset their password when they forget it?的直接链接" title="How should I allow users to reset their password when they forget it?的直接链接" translate="no">​</a></h3>
<p>It is my personal opinion that all password reset mechanisms in widespread use today are insecure. If you have high security requirements, such as an encryption service would, do not let the user reset their password.</p>
<p>Most websites use an email loop to authenticate users who have forgotten their password. To do this, generate a random <strong>single-use</strong> token that is strongly tied to the account. Include it in a password reset link sent to the user&#x27;s email address. When the user clicks a password reset link containing a valid token, prompt them for a new password. Be sure that the token is strongly tied to the user account so that an attacker can&#x27;t use a token sent to his own email address to reset a different user&#x27;s password.</p>
<p>The token must be set to expire in 15 minutes or after it is used, whichever comes first. It is also a good idea to expire any existing password tokens when the user logs in (they remembered their password) or requests another reset token. If a token doesn&#x27;t expire, it can be forever used to break into the user&#x27;s account. Email (SMTP) is a plain-text protocol, and there may be malicious routers on the internet recording email traffic. And, a user&#x27;s email account (including the reset link) may be compromised long after their password has been changed. Making the token expire as soon as possible reduces the user&#x27;s exposure to these attacks.</p>
<p>Attackers will be able to modify the tokens, so don&#x27;t store the user account information or timeout information in them. They should be an unpredictable random binary blob used only to identify a record in a database table.</p>
<p>Never send the user a new password over email. Remember to pick a new random salt when the user resets their password. Don&#x27;t re-use the one that was used to hash their old password.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-should-i-do-if-my-user-account-database-gets-leakedhacked">What should I do if my user account database gets leaked/hacked?<a href="#what-should-i-do-if-my-user-account-database-gets-leakedhacked" class="hash-link" aria-label="What should I do if my user account database gets leaked/hacked?的直接链接" title="What should I do if my user account database gets leaked/hacked?的直接链接" translate="no">​</a></h3>
<p>Your first priority is to determine how the system was compromised and patch the vulnerability the attacker used to get in. If you do not have experience responding to breaches, I highly recommend hiring a third-party security firm.</p>
<p>It may be tempting to cover up the breach and hope nobody notices. However, trying to cover up a breach makes you look worse, because you&#x27;re putting your users at further risk by not informing them that their passwords and other personal information may be compromised. You must inform your users as soon as possible—even if you don&#x27;t yet fully understand what happened. Put a notice on the front page of your website that links to a page with more detailed information, and send a notice to each user by email if possible.</p>
<p>Explain to your users exactly how their passwords were protected—hopefully hashed with salt—and that even though they were protected with a salted hash, a malicious hacker can still run dictionary and brute force attacks on the hashes. Malicious hackers will use any passwords they find to try to login to a user&#x27;s account on a different website, hoping they used the same password on both websites. Inform your users of this risk and recommend that they change their password on any website or service where they used a similar password. Force them to change their password for your service the next time they log in. Most users will try to &quot;change&quot; their password to the original password to get around the forced change quickly. Use the current password hash to ensure that they cannot do this.</p>
<p>It is likely, even with salted slow hashes, that an attacker will be able to crack some of the weak passwords very quickly. To reduce the attacker&#x27;s window of opportunity to use these passwords, you should require, in addition to the current password, an email loop for authentication until the user has changed their password. See the previous question, &quot;How should I allow users to reset their password when they forget it?&quot; for tips on implementing email loop authentication.</p>
<p>Also tell your users what kind of personal information was stored on the website. If your database includes credit card numbers, you should instruct your users to look over their recent and future bills closely and cancel their credit card.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-should-my-password-policy-be-should-i-enforce-strong-passwords">What should my password policy be? Should I enforce strong passwords?<a href="#what-should-my-password-policy-be-should-i-enforce-strong-passwords" class="hash-link" aria-label="What should my password policy be? Should I enforce strong passwords?的直接链接" title="What should my password policy be? Should I enforce strong passwords?的直接链接" translate="no">​</a></h3>
<p>If your service doesn&#x27;t have strict security requirements, then don&#x27;t limit your users. I recommend showing users information about the strength of their password as they type it, letting them decide how secure they want their password to be. If you have special security needs, enforce a minimum length of 12 characters and require at least two letters, two digits, and two symbols.</p>
<p>Do not force your users to change their password more often than once every six months, as doing so creates &quot;user fatigue&quot; and makes users less likely to choose good passwords. Instead, train users to change their password whenever they feel it has been compromised, and to never tell their password to anyone. If it is a business setting, encourage employees to use paid time to memorize and practice their password.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="if-an-attacker-has-access-to-my-database-cant-they-just-replace-the-hash-of-my-password-with-their-own-hash-and-login">If an attacker has access to my database, can&#x27;t they just replace the hash of my password with their own hash and login?<a href="#if-an-attacker-has-access-to-my-database-cant-they-just-replace-the-hash-of-my-password-with-their-own-hash-and-login" class="hash-link" aria-label="If an attacker has access to my database, can&#x27;t they just replace the hash of my password with their own hash and login?的直接链接" title="If an attacker has access to my database, can&#x27;t they just replace the hash of my password with their own hash and login?的直接链接" translate="no">​</a></h3>
<p>Yes, but if someone has access to your database, they probably already have access to everything on your server, so they wouldn&#x27;t need to login to your account to get what they want. The purpose of password hashing (in the context of a website) is not to protect the website from being breached, but to protect the passwords if a breach does occur.</p>
<p>You can prevent hashes from being replaced during a SQL injection attack by connecting to the database with two users with different permissions. One for the &#x27;create account&#x27; code and one for the &#x27;login&#x27; code. The &#x27;create account&#x27; code should be able to read and write to the user table, but the &#x27;login&#x27; code should only be able to read.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-do-i-have-to-use-a-special-algorithm-like-hmac-why-cant-i-just-append-the-password-to-the-secret-key">Why do I have to use a special algorithm like HMAC? Why can&#x27;t I just append the password to the secret key?<a href="#why-do-i-have-to-use-a-special-algorithm-like-hmac-why-cant-i-just-append-the-password-to-the-secret-key" class="hash-link" aria-label="Why do I have to use a special algorithm like HMAC? Why can&#x27;t I just append the password to the secret key?的直接链接" title="Why do I have to use a special algorithm like HMAC? Why can&#x27;t I just append the password to the secret key?的直接链接" translate="no">​</a></h3>
<p>Hash functions like MD5, SHA1, and SHA2 use the <a href="http://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction" target="_blank" rel="noopener noreferrer" class="">Merkle–Damgård construction</a>, which makes them vulnerable to what are known as length extension attacks. This means that given a hash H(X), an attacker can find the value of H(pad(X) + Y), for any other string Y, without knowing X. pad(X) is the padding function used by the hash.</p>
<p>This means that given a hash H(key + message), an attacker can compute H(pad(key + message) + extension), without knowing the key. If the hash was being used as a message authentication code, using the key to prevent an attacker from being able to modify the message and replace it with a different valid hash, the system has failed, since the attacker now has a valid hash of message + extension.</p>
<p>It is not clear how an attacker could use this attack to crack a password hash quicker. However, because of the attack, it is considered bad practice to use a plain hash function for keyed hashing. A clever cryptographer may one day come up with a clever way to use these attacks to make cracking faster, so use HMAC.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="should-the-salt-come-before-or-after-the-password">Should the salt come before or after the password?<a href="#should-the-salt-come-before-or-after-the-password" class="hash-link" aria-label="Should the salt come before or after the password?的直接链接" title="Should the salt come before or after the password?的直接链接" translate="no">​</a></h3>
<p>It doesn&#x27;t matter, but pick one and stick with it for interoperability&#x27;s sake. Having the salt come before the password seems to be more common.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-does-the-hashing-code-on-this-page-compare-the-hashes-in-length-constant-time">Why does the hashing code on this page compare the hashes in &quot;length-constant&quot; time?<a href="#why-does-the-hashing-code-on-this-page-compare-the-hashes-in-length-constant-time" class="hash-link" aria-label="Why does the hashing code on this page compare the hashes in &quot;length-constant&quot; time?的直接链接" title="Why does the hashing code on this page compare the hashes in &quot;length-constant&quot; time?的直接链接" translate="no">​</a></h3>
<p>Comparing the hashes in &quot;length-constant&quot; time ensures that an attacker cannot extract the hash of a password in an on-line system using a timing attack, then crack it off-line.</p>
<p>The standard way to check if two sequences of bytes (strings) are the same is to compare the first byte, then the second, then the third, and so on. As soon as you find a byte that isn&#x27;t the same for both strings, you know they are different and can return a negative response immediately. If you make it through both strings without finding any bytes that differ, you know the strings are the same and can return a positive result. This means that comparing two strings can take a different amount of time depending on how much of the strings match.</p>
<p>For example, a standard comparison of the strings &quot;xyzabc&quot; and &quot;abcxyz&quot; would immediately see that the first character is different and wouldn&#x27;t bother to check the rest of the string. On the other hand, when the strings &quot;aaaaaaaaaaB&quot; and &quot;aaaaaaaaaaZ&quot; are compared, the comparison algorithm scans through the block of &quot;a&quot; before it determines the strings are unequal.</p>
<p>Suppose an attacker wants to break into an on-line system that rate limits authentication attempts to one attempt per second. Also suppose the attacker knows all of the parameters to the password hash (salt, hash type, etc), except for the hash and (obviously) the password. If the attacker can get a precise measurement of how long it takes the on-line system to compare the hash of the real password with the hash of a password the attacker provides, he can use the timing attack to extract part of the hash and crack it using an offline attack, bypassing the system&#x27;s rate limiting.</p>
<p>First, the attacker finds 256 strings whose hashes begin with every possible byte. He sends each string to the on-line system, recording the amount of time it takes the system to respond. The string that takes the longest will be the one whose hash&#x27;s first byte matches the real hash&#x27;s first byte. The attacker now knows the first byte, and can continue the attack in a similar manner on the second byte, then the third, and so on. Once the attacker knows enough of the hash, he can use his own hardware to crack it, without being rate limited by the system.</p>
<p>It might seem like it would be impossible to run a timing attack over a network. However, it has been done, and has been <a href="https://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf" target="_blank" rel="noopener noreferrer" class="">shown to be practical</a>. That&#x27;s why the code on this page compares strings in a way that takes the same amount of time no matter how much of the strings match.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="how-does-the-slowequals-code-work">How does the SlowEquals code work?<a href="#how-does-the-slowequals-code-work" class="hash-link" aria-label="How does the SlowEquals code work?的直接链接" title="How does the SlowEquals code work?的直接链接" translate="no">​</a></h3>
<p>The previous question explains why SlowEquals is necessary, this one explains how the code actually works.</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static boolean slowEquals(byte[] a, byte[] b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int diff = a.length ^ b.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for(int i = 0; i &lt; a.length &amp;&amp; i &lt; b.length; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">diff |= a[i] ^ b[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return diff == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>The code uses the XOR &quot;^&quot; operator to compare integers for equality, instead of the &quot;==&quot; operator. The reason why is explained below. The result of XORing two integers will be zero if and only if they are exactly the same. This is because 0 XOR 0 = 0, 1 XOR 1 = 0, 0 XOR 1 = 1, 1 XOR 0 = 1. If we apply that to all the bits in both integers, the result will be zero only if all the bits matched.</p>
<p>So, in the first line, if <code>a.length</code> is equal to <code>b.length</code>, the diff variable will get a zero value, but if not, it will get some non-zero value. Next, we compare the bytes using XOR, and OR the result into diff. This will set diff to a non-zero value if the bytes differ. Because ORing never un-sets bits, the only way diff will be zero at the end of the loop is if it was zero before the loop began (a.length == b.length) and all of the bytes in the two arrays match (none of the XORs resulted in a non-zero value).</p>
<p>The reason we need to use XOR instead of the &quot;==&quot; operator to compare integers is that &quot;==&quot; is usually translated/compiled/interpreted as a branch. For example, the C code &quot; <code>diff &amp;= a == b</code> &quot; might compile to the following x86 assembly:</p>
<p>MOV EAX, [A]<br>
<!-- -->CMP [B], EAX<br>
<!-- -->JZ equal<br>
<!-- -->JMP done<br>
<!-- -->equal:<br>
<!-- -->AND [VALID], 1<br>
<!-- -->done:<br>
<!-- -->AND [VALID], 0</p>
<p>The branching makes the code execute in a different amount of time depending on the equality of the integers and the CPU&#x27;s internal branch prediction state.</p>
<p>The C code &quot; <code>diff |= a ^ b</code> &quot; should compile to something like the following, whose execution time does not depend on the equality of the integers:</p>
<p>MOV EAX, [A]<br>
<!-- -->XOR EAX, [B]<br>
<!-- -->OR [DIFF], EAX</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-bother-hashing">Why bother hashing?<a href="#why-bother-hashing" class="hash-link" aria-label="Why bother hashing?的直接链接" title="Why bother hashing?的直接链接" translate="no">​</a></h3>
<p>Your users are entering their password into your website. They are trusting you with their security. If your database gets hacked, and your users&#x27; passwords are unprotected, then malicious hackers can use those passwords to compromise your users&#x27; accounts on other websites and services (most people use the same password everywhere). It&#x27;s not just your security that&#x27;s at risk, it&#x27;s your users&#x27;. You are responsible for your users&#x27; security.</p>
</div></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/excerpts/tech/dice"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">EFF Dice-Generated Passphrases</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/excerpts/tech/startup-ideas"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">How to Get Startup Ideas</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#salted-password-hashing---doing-it-right" class="table-of-contents__link toc-highlight">Salted Password Hashing - Doing it Right</a></li><li><a href="#what-is-password-hashing" class="table-of-contents__link toc-highlight">What is password hashing?</a></li><li><a href="#how-hashes-are-cracked" class="table-of-contents__link toc-highlight">How Hashes are Cracked</a><ul><li><a href="#dictionary-and-brute-force-attacks" class="table-of-contents__link toc-highlight">Dictionary and Brute Force Attacks</a></li><li><a href="#lookup-tables" class="table-of-contents__link toc-highlight">Lookup Tables</a></li><li><a href="#reverse-lookup-tables" class="table-of-contents__link toc-highlight">Reverse Lookup Tables</a></li><li><a href="#rainbow-tables" class="table-of-contents__link toc-highlight">Rainbow Tables</a></li></ul></li><li><a href="#adding-salt" class="table-of-contents__link toc-highlight">Adding Salt</a></li><li><a href="#the-wrong-way-short-salt--salt-reuse" class="table-of-contents__link toc-highlight">The WRONG Way: Short Salt &amp; Salt Reuse</a><ul><li><a href="#salt-reuse" class="table-of-contents__link toc-highlight">Salt Reuse</a></li><li><a href="#short-salt" class="table-of-contents__link toc-highlight">Short Salt</a></li></ul></li><li><a href="#the-wrong-way-double-hashing--wacky-hash-functions" class="table-of-contents__link toc-highlight">The WRONG Way: Double Hashing &amp; Wacky Hash Functions</a></li><li><a href="#hash-collisions" class="table-of-contents__link toc-highlight">Hash Collisions</a></li><li><a href="#the-right-way-how-to-hash-properly" class="table-of-contents__link toc-highlight">The RIGHT Way: How to Hash Properly</a><ul><li><a href="#the-basics-hashing-with-salt" class="table-of-contents__link toc-highlight">The Basics: Hashing with Salt</a></li><li><a href="#making-password-cracking-harder-slow-hash-functions" class="table-of-contents__link toc-highlight">Making Password Cracking Harder: Slow Hash Functions</a></li><li><a href="#impossible-to-crack-hashes-keyed-hashes-and-password-hashing-hardware" class="table-of-contents__link toc-highlight">Impossible-to-crack Hashes: Keyed Hashes and Password Hashing Hardware</a></li></ul></li><li><a href="#other-security-measures" class="table-of-contents__link toc-highlight">Other Security Measures</a></li><li><a href="#frequently-asked-questions" class="table-of-contents__link toc-highlight">Frequently Asked Questions</a><ul><li><a href="#what-hash-algorithm-should-i-use" class="table-of-contents__link toc-highlight">What hash algorithm should I use?</a></li><li><a href="#how-should-i-allow-users-to-reset-their-password-when-they-forget-it" class="table-of-contents__link toc-highlight">How should I allow users to reset their password when they forget it?</a></li><li><a href="#what-should-i-do-if-my-user-account-database-gets-leakedhacked" class="table-of-contents__link toc-highlight">What should I do if my user account database gets leaked/hacked?</a></li><li><a href="#what-should-my-password-policy-be-should-i-enforce-strong-passwords" class="table-of-contents__link toc-highlight">What should my password policy be? Should I enforce strong passwords?</a></li><li><a href="#if-an-attacker-has-access-to-my-database-cant-they-just-replace-the-hash-of-my-password-with-their-own-hash-and-login" class="table-of-contents__link toc-highlight">If an attacker has access to my database, can&#39;t they just replace the hash of my password with their own hash and login?</a></li><li><a href="#why-do-i-have-to-use-a-special-algorithm-like-hmac-why-cant-i-just-append-the-password-to-the-secret-key" class="table-of-contents__link toc-highlight">Why do I have to use a special algorithm like HMAC? Why can&#39;t I just append the password to the secret key?</a></li><li><a href="#should-the-salt-come-before-or-after-the-password" class="table-of-contents__link toc-highlight">Should the salt come before or after the password?</a></li><li><a href="#why-does-the-hashing-code-on-this-page-compare-the-hashes-in-length-constant-time" class="table-of-contents__link toc-highlight">Why does the hashing code on this page compare the hashes in &quot;length-constant&quot; time?</a></li><li><a href="#how-does-the-slowequals-code-work" class="table-of-contents__link toc-highlight">How does the SlowEquals code work?</a></li><li><a href="#why-bother-hashing" class="table-of-contents__link toc-highlight">Why bother hashing?</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2026 Fan's life, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>